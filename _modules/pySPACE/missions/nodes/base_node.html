<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pySPACE.missions.nodes.base_node &mdash; pySPACE documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/pySPACE.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.3 release',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/pyspace-logo.ico"/>
    <link rel="top" title="pySPACE documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pySPACE documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/pyspace-logo_small.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pySPACE.missions.nodes.base_node</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Skeleton for an elemental transformation of the signal</span>

<span class="sd">This includes some exception and metaclass handling, but the most important part</span>
<span class="sd">is the :class:`~pySPACE.missions.nodes.base_node.BaseNode`.</span>

<span class="sd">.. note::</span>
<span class="sd">    This module includes a reimplementation of the MDP node class that</span>
<span class="sd">    is better suited for the purposes of pySPACE. For instance</span>
<span class="sd">    it provides methods to allow the benchmarking of supervised training,</span>
<span class="sd">    storing, loading, cross validation, logging ...</span>
<span class="sd">    Furthermore, it takes care for the totally different data types,</span>
<span class="sd">    because in our case, the input data is 2-dimensional.</span>
<span class="sd">    These differences in concept are quite essential and resulted in</span>
<span class="sd">    creating an &#39;own&#39; implementation, comprising the code into one module,</span>
<span class="sd">    instead of keeping the inheritance of the MDP node class.</span>
<span class="sd">    Nevertheless a lot of code was copied from this great library.</span>

<span class="sd">.. image:: ../../graphics/node.png</span>
<span class="sd">   :width: 500</span>

<span class="sd">:Author: Jan Hendrik Metzen (jhm@informatik.uni-bremen.de)</span>
<span class="sd">:Created: 2008/11/25</span>

<span class="sd">MDP (version 3.3) is distributed under the following BSD license::</span>

<span class="sd">    This file is part of Modular toolkit for Data Processing (MDP).</span>
<span class="sd">    All the code in this package is distributed under the following conditions:</span>

<span class="sd">    Copyright (c) 2003-2012, MDP Developers &lt;mdp-toolkit-devel@lists.sourceforge.net&gt;</span>

<span class="sd">    All rights reserved.</span>

<span class="sd">    Redistribution and use in source and binary forms, with or without</span>
<span class="sd">    modification, are permitted provided that the following conditions are met:</span>

<span class="sd">        * Redistributions of source code must retain the above copyright</span>
<span class="sd">          notice, this list of conditions and the following disclaimer.</span>
<span class="sd">        * Redistributions in binary form must reproduce the above copyright</span>
<span class="sd">          notice, this list of conditions and the following disclaimer in the</span>
<span class="sd">          documentation and/or other materials provided with the distribution.</span>
<span class="sd">        * Neither the name of the Modular toolkit for Data Processing (MDP)</span>
<span class="sd">          nor the names of its contributors may be used to endorse or promote</span>
<span class="sd">          products derived from this software without specific prior written</span>
<span class="sd">          permission.</span>

<span class="sd">    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<span class="sd">    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="sd">    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="sd">    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span>
<span class="sd">    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="sd">    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="sd">    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="sd">    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="sd">    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="sd">    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="c1"># logging imports</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">logging.handlers</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">cPickle</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">pySPACE</span>
<span class="kn">from</span> <span class="nn">pySPACE.tools.memoize_generator</span> <span class="kn">import</span> <span class="n">MemoizeGenerator</span>


<span class="c1"># Exceptions from MDP</span>
<div class="viewcode-block" id="NodeException"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.NodeException">[docs]</a><span class="k">class</span> <span class="nc">NodeException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for exceptions in `Node` subclasses.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="InconsistentDimException"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.InconsistentDimException">[docs]</a><span class="k">class</span> <span class="nc">InconsistentDimException</span><span class="p">(</span><span class="n">NodeException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when there is a conflict setting the dimensions</span>

<span class="sd">    Note that incoming data with conflicting dimensionality raises a normal</span>
<span class="sd">    `NodeException`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="TrainingException"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.TrainingException">[docs]</a><span class="k">class</span> <span class="nc">TrainingException</span><span class="p">(</span><span class="n">NodeException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for exceptions in the training phase.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="TrainingFinishedException"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.TrainingFinishedException">[docs]</a><span class="k">class</span> <span class="nc">TrainingFinishedException</span><span class="p">(</span><span class="n">TrainingException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when the `Node.train` method is called although the</span>
<span class="sd">    training phase is closed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="IsNotTrainableException"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.IsNotTrainableException">[docs]</a><span class="k">class</span> <span class="nc">IsNotTrainableException</span><span class="p">(</span><span class="n">TrainingException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when the `Node.train` method is called although the</span>
<span class="sd">    node is not trainable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="NodeMetaclass"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.NodeMetaclass">[docs]</a><span class="k">class</span> <span class="nc">NodeMetaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; General meta class for future features &quot;&quot;&quot;</span>
<div class="viewcode-block" id="NodeMetaclass.__new__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.NodeMetaclass.__new__">[docs]</a>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Forward to standard method from type &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NodeMetaclass</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BaseNode"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode">[docs]</a><span class="k">class</span> <span class="nc">BaseNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Main base class for nodes which forwards data without processing</span>

<span class="sd">    It provides methods to allow the benchmarking of supervised training,</span>
<span class="sd">    storing, loading, cross validation, logging, ...</span>
<span class="sd">    Furthermore, it takes care for different data types.</span>
<span class="sd">    The input data is currently two-dimensional.</span>
<span class="sd">    It can be:</span>

<span class="sd">        * :class:`~pySPACE.resources.data_types.time_series.TimeSeries` or</span>
<span class="sd">        * :class:`~pySPACE.resources.data_types.feature_vector.FeatureVector` or</span>
<span class="sd">        * :class:`~pySPACE.resources.data_types.prediction_vector.PredictionVector`</span>
<span class="sd">        * which all inherit from a common :class:`~pySPACE.resources.data_types.base.BaseData`.</span>

<span class="sd">    In the following parameters are introduced which do not give any</span>
<span class="sd">    functionality but which could generally be used by inheriting nodes.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        :input_dim:</span>
<span class="sd">            Dimension(s) of the input data.</span>
<span class="sd">            By default determined automatically.</span>

<span class="sd">            (*optional, default: None*)</span>

<span class="sd">        :output_dim:</span>
<span class="sd">            Dimension(s) of the output data.</span>
<span class="sd">            By default determined automatically.</span>

<span class="sd">            (*optional, default: None*)</span>

<span class="sd">        :dtype:</span>
<span class="sd">            Data type of the data array.</span>
<span class="sd">            By default determined automatically.</span>

<span class="sd">            (*optional, default: None*)</span>

<span class="sd">        :keep_in_history:</span>
<span class="sd">            This parameter is a specialty, which comes with the</span>
<span class="sd">            :class:`~pySPACE.resources.data_types.base.BaseData`.</span>
<span class="sd">            The execution result of the node</span>
<span class="sd">            is copied into the *history* parameter of the object.</span>
<span class="sd">            Additionally, the *specs* of the object receive an entry labeled &#39;</span>
<span class="sd">            node_specs&#39; containing a dictionary of additional information</span>
<span class="sd">            from the saving node.</span>

<span class="sd">            Especially :mod:`~pySPACE.missions.nodes.visualization` nodes</span>
<span class="sd">            may use this functionality to visualize the change of the</span>
<span class="sd">            processing of the data.</span>

<span class="sd">            (*optional, default: False*)</span>

<span class="sd">        :load_path:</span>
<span class="sd">            This is the standard variable to load processing information for</span>
<span class="sd">            the node especially from previous seen data.</span>

<span class="sd">            Examples for the usage, are the loading of spatial filters,</span>
<span class="sd">            classifiers or feature normalizations.</span>
<span class="sd">            If a parameter load_path is provided for any node, the</span>
<span class="sd">            node is able to replace some keywords.</span>

<span class="sd">            So far implemented replacements:</span>

<span class="sd">                :__RUN__: current run number</span>
<span class="sd">                :__SPLIT__: current split number</span>

<span class="sd">            Be aware that corresponding split and run numbers don&#39;t</span>
<span class="sd">            necessarily mean that you&#39;re operating on the same data.</span>

<span class="sd">            Especially if cross validations generated the splits, there</span>
<span class="sd">            is no reason to believe that the current splitting has</span>
<span class="sd">            anything to do with a previous one!</span>

<span class="sd">            .. note::</span>
<span class="sd">                The keywords **__INPUT_DATASET__** and **__RESULT_DIRECTORY__** can</span>
<span class="sd">                also be used. The replacement of these keyword is done</span>
<span class="sd">                in the :class:`~pySPACE.missions.operations.node_chain.NodeChainOperation`.</span>

<span class="sd">            (*optional, default: None*)</span>

<span class="sd">        :store:</span>
<span class="sd">            If the node parameter *store* is set to &#39;True&#39;, before each reset</span>
<span class="sd">            the internal state of the node is stored (pickled) with the</span>
<span class="sd">            store_state method.</span>

<span class="sd">            (*optional, default: False*)</span>

<span class="sd">        :retrain:</span>
<span class="sd">            If your node has the method *_inc_train* and you want to use</span>
<span class="sd">            *incremental* training during testing or application phase,</span>
<span class="sd">            this parameter has to be set to True.</span>
<span class="sd">            After processing the data, the node will immediately get the label</span>
<span class="sd">            to learn changes in the data.</span>

<span class="sd">            For more subtle retraining in the online application,</span>
<span class="sd">            you will additionally have to use the</span>
<span class="sd">            parameter *buffering* (&#39;True&#39;) to save all occurring samples</span>
<span class="sd">            in the testing phase. The retraining is then activated by</span>
<span class="sd">            calling the method *present_label(label)*:</span>

<span class="sd">                If the the label is *None*, only the first buffered element</span>
<span class="sd">                is deleted. This is used, if we don&#39;t get a label,</span>
<span class="sd">                if we are insecure of the true label or</span>
<span class="sd">                if we simply do not want to retrain on this sample.</span>
<span class="sd">                In the other case, the presented label belongs to the first</span>
<span class="sd">                buffered element, which is then given to the *_inc_train* method</span>
<span class="sd">                together with its label.</span>
<span class="sd">                Afterwards the buffered element is deleted.</span>

<span class="sd">                The method could be called in different ways in a sink node,</span>
<span class="sd">                to simulate different ways of getting labels and different ways</span>
<span class="sd">                of incremental learning.</span>

<span class="sd">                Furthermore, it could used by node_chain_scripts</span>
<span class="sd">                as they can be found in the</span>
<span class="sd">                :mod:`~pySPACE.environments.live` environment,</span>
<span class="sd">                where we have the real</span>
<span class="sd">                situation, that we have to check after the classification,</span>
<span class="sd">                what was the right label of the data.</span>

<span class="sd">            .. note:: Before using this parameter you should always check, if</span>
<span class="sd">                      the node is able for incremental learning!</span>

<span class="sd">            (*optional, default: False*)</span>

<span class="sd">        :buffering:</span>
<span class="sd">            This switch is responsible for real time *incremental*</span>
<span class="sd">            learning of the node in applications (live environment),</span>
<span class="sd">            by mainly buffering all samples in the execute method in the testing</span>
<span class="sd">            phase.</span>

<span class="sd">            If *buffering* is set to &#39;True&#39;, the *retrain* parameter should also be</span>
<span class="sd">            and the node must have an *_inc_train* method.</span>
<span class="sd">            Furthermore the *present_label* method must be called externally.</span>
<span class="sd">            Otherwise you will run into memory issues.</span>

<span class="sd">            For more details see the documentation of the *retrain* parameter.</span>

<span class="sd">            (*optional, default: False*)</span>

<span class="sd">        :zero_training:</span>
<span class="sd">            This enforces the node to be not trained, though it is trainable.</span>

<span class="sd">            .. warning:: For usage in nodes, the algorithms need to define</span>
<span class="sd">                proper defaults in the initialization, e.g. by using the</span>
<span class="sd">                *load_path* parameter.</span>

<span class="sd">            (*optional, default: True*)</span>

<span class="sd">        :kwargs_warning:</span>
<span class="sd">            Raise a warning if unexpected keyword arguments are given.</span>

<span class="sd">            (*optional, default: True*)</span>

<span class="sd">    **Implementing your own Node**</span>

<span class="sd">    For finding out, how to implement your own node, have a look at the</span>
<span class="sd">    :mod:`~pySPACE.missions.nodes.templates`.</span>

<span class="sd">    **Exemplary Call**</span>

<span class="sd">    .. code-block:: yaml</span>

<span class="sd">        -</span>
<span class="sd">            node : Noop</span>
<span class="sd">            parameters :</span>
<span class="sd">                keep_in_history : True</span>


<span class="sd">    :input:    Any (e.g. FeatureVector)</span>
<span class="sd">    :output:   Any1 (e.g. FeatureVector)</span>
<span class="sd">    :Author: Mario Michael Krell and many more (krell@uni-bremen.de)</span>
<span class="sd">    :Created: before 2008/09/28</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># setting the meta class</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">NodeMetaclass</span>

<div class="viewcode-block" id="BaseNode.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">retrain</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">input_dim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">output_dim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kwargs_warning</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This initialization is necessary for every node</span>

<span class="sd">        So make sure, that you use it via the *super* method in each new node.</span>
<span class="sd">        The method cares for the setting of the basic parameters, including</span>
<span class="sd">        parameters for storing,</span>
<span class="sd">        and handling of training and test data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sanity checks</span>
        <span class="k">assert</span> <span class="n">store</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">],</span> \
            <span class="s2">&quot;Passing inappropriate value </span><span class="si">%s</span><span class="s2"> for parameter &#39;store&#39;.&quot;</span> <span class="o">%</span> <span class="n">store</span>

        <span class="k">assert</span> <span class="n">retrain</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">],</span> \
            <span class="s2">&quot;Passing inappropriate value </span><span class="si">%s</span><span class="s2"> for parameter &#39;retrain&#39;.&quot;</span> \
            <span class="o">%</span> <span class="n">retrain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retrainable</span> <span class="o">=</span> <span class="n">retrain</span>

        <span class="c1">#: parameter for retraining in application</span>
        <span class="c1">#: see *present_label*</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffering</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s2">&quot;buffering&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffering</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;buffering&quot;</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">zero_training</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s2">&quot;zero_training&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_training</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;zero_training&quot;</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffering</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrainable</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Buffering nodes should retrains!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retraining_phase</span><span class="o">=</span><span class="bp">False</span>
        
        <span class="c1"># whether to save data or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_intermediate_results</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s2">&quot;save_intermediate_results&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_intermediate_results</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;save_intermediate_results&quot;</span><span class="p">]</span>

        <span class="c1"># initialize basic attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_dim</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_dim</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c1"># call set functions for properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_input_dim</span><span class="p">(</span><span class="n">input_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_output_dim</span><span class="p">(</span><span class="n">output_dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># skip the training phase if the node is not trainable</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_training</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_training</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase_started</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this var stores at which point in the training sequence we are</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># this var is False if the training of the current phase hasn&#39;t</span>
            <span class="c1">#  started yet, True otherwise</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase_started</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c1"># this var is False if the complete training is finished</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_training</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_for_training</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_for_testing</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># distinguish execution on training and test data</span>
        <span class="c1"># since some nodes only want to handle test data and ignore</span>
        <span class="c1"># training data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_training_execution_phase</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1">#: Do we have to remember the outputs of this node for later reuse?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">caching</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_path</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;load_path&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_in_history</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;keep_in_history&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_specs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">retrain_data</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retrain_label</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># Switch for in-/homogenous data (e.g. data with different sampling</span>
        <span class="c1"># frequencies). Has to be handled from the node which can deal with </span>
        <span class="c1"># inhomogenous data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">homogenous</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;homogenous&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c1"># Set the default run number which gives the number of the current </span>
        <span class="c1"># iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_number</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Every Parameter is stored since we reset them with every new spit.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs_warning</span><span class="p">:</span>
            <span class="n">remove_kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;homogeneous&quot;</span><span class="p">,</span> <span class="s2">&quot;keep_in_history&quot;</span><span class="p">,</span> <span class="s2">&quot;load_path&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;save_intermediate_results&quot;</span><span class="p">,</span> <span class="s2">&quot;zero_training&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;buffering&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">remove_kwargs</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The parameter &#39;</span><span class="si">%s</span><span class="s2">&#39; seems to be unused in </span><span class="si">%s</span><span class="s2">.&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span> <span class="o">+</span>
                        <span class="s2">&quot; Either you specified it on purpose, you spelled it &quot;</span> <span class="o">+</span>
                        <span class="s2">&quot;wrong, or there is an implementation inconsistency.&quot;</span><span class="p">)</span></div>
        

    <span class="c1">###### Methods, which can be overwritten by inheriting nodes ######</span>
<div class="viewcode-block" id="BaseNode._train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._train">[docs]</a>    <span class="k">def</span> <span class="nf">_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Give the training data to the node</span>

<span class="sd">        If a node is trainable, this method is called and *has to be* implemented.</span>
<span class="sd">        Optionally the :func:`_stop_training` method can be additionally implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The node </span><span class="si">%s</span><span class="s2"> is not trainable&quot;</span>
                                      <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode._stop_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._stop_training">[docs]</a>    <span class="k">def</span> <span class="nf">_stop_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Called method after the training data went through the node</span>

<span class="sd">        It can be overwritten by the inheriting node.</span>
<span class="sd">        Normally, the :func:`_train` method only collects the data</span>
<span class="sd">        and this method does the real (batch) training.</span>

<span class="sd">        By default this method does nothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="BaseNode._execute"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._execute">[docs]</a>    <span class="k">def</span> <span class="nf">_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Elemental processing step (**key component**)</span>

<span class="sd">        This method should be overwritten by the inheriting node.</span>
<span class="sd">        It implements the final processing of the data of the node.</span>

<span class="sd">        By default the data is just forwarded.</span>

<span class="sd">        Some nodes only visualize or analyze training data</span>
<span class="sd">        or only handle the data sets without changing the data</span>
<span class="sd">        and so they do not need this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="BaseNode._check_train_args"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._check_train_args">[docs]</a>    <span class="k">def</span> <span class="nf">_check_train_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Checks if the arguments are correct for training</span>

<span class="sd">        Implemented by subclasses if needed.</span>

<span class="sd">        .. todo:: Check if this method copy is needed and</span>
<span class="sd">                  if there is a good use-case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="BaseNode._inc_train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._inc_train">[docs]</a>    <span class="k">def</span> <span class="nf">_inc_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span> <span class="n">class_label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Method to be overwritten by subclass for incremental training after initial training &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The node </span><span class="si">%s</span><span class="s2"> does not implement incremental training.&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span></div>

    <span class="c1">#@staticmethod</span>
<div class="viewcode-block" id="BaseNode.is_trainable"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.is_trainable">[docs]</a>    <span class="k">def</span> <span class="nf">is_trainable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return True if the node can be trained, False otherwise</span>

<span class="sd">        *default: False*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span></div>

    <span class="c1">#@staticmethod</span>
<div class="viewcode-block" id="BaseNode.is_supervised"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.is_supervised">[docs]</a>    <span class="k">def</span> <span class="nf">is_supervised</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns whether this node requires supervised training</span>

<span class="sd">        *default: False*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="BaseNode.get_own_transformation"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_own_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">get_own_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; If the node has a transformation, it should overwrite this method</span>

<span class="sd">        The format should be::</span>

<span class="sd">             (main transformation, offset and further parameters, relevant names, transformation type)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="BaseNode.get_input_types"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_input_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_input_types</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">as_string</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return all available input types from the node</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            :as_string:</span>
<span class="sd">                Tells the method whether it should return</span>
<span class="sd">                a string encoding of the type or a class instance</span>

<span class="sd">            (*default: True*)</span>

<span class="sd">            .. note ::</span>
<span class="sd">                Strings have less overhead than class instances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;BaseNode&quot;</span><span class="p">:</span>
            <span class="c1"># if the current node is the base node, it need not have</span>
            <span class="c1"># defined a variable called input_types but can</span>
            <span class="c1"># accept all inputs</span>
            <span class="c1"># if it had such a variable, the if clauses below would</span>
            <span class="c1"># not work and the default would be to accept all inputs</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;PredictionVector&quot;</span><span class="p">,</span> <span class="s2">&quot;FeatureVector&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;TimeSeries&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s2">&quot;input_types&quot;</span><span class="p">):</span>
            <span class="n">pack</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pack</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;preprocessing&#39;</span><span class="p">,</span> <span class="s1">&#39;spatial_filtering&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;feature_generation&#39;</span><span class="p">]:</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">input_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;TimeSeries&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pack</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;feature_selection&quot;</span><span class="p">,</span> <span class="s2">&quot;classification&quot;</span><span class="p">]</span> <span class="ow">or</span> \
                    <span class="n">module</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;feature_normalization&quot;</span><span class="p">,</span> <span class="s2">&quot;compression&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;scikits_nodes&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s2">&quot;ensemble&quot;</span><span class="p">:</span>
                    <span class="n">cls</span><span class="o">.</span><span class="n">input_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;PredictionVector&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cls</span><span class="o">.</span><span class="n">input_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;FeatureVector&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">module</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;score_transformation&quot;</span><span class="p">,</span> <span class="s2">&quot;threshold_optimization&quot;</span><span class="p">]:</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">input_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;PredictionVector&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pack</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">input_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;PredictionVector&quot;</span><span class="p">,</span> <span class="s2">&quot;FeatureVector&quot;</span><span class="p">,</span>
                                 <span class="s2">&quot;TimeSeries&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">as_string</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">input_types</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">one_type</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">input_types</span><span class="p">:</span>
                <span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">string_to_class</span><span class="p">(</span><span class="n">one_type</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">types</span></div>

<div class="viewcode-block" id="BaseNode.get_output_type"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_output_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_output_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_type</span><span class="p">,</span> <span class="n">as_string</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return output type depending on the *input_type*</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            :as_string:</span>
<span class="sd">                Tells the method whether it should return</span>
<span class="sd">                a string encoding of the type or a class instance</span>

<span class="sd">            (*default: True*)</span>

<span class="sd">            :input_type:</span>
<span class="sd">                The input type of the node.</span>
<span class="sd">                In most cases, the input depends on the input</span>
<span class="sd">                and can not be inferred from the algorithm category.</span>

<span class="sd">        .. note ::</span>

<span class="sd">            Strings have less overhead than class instances and</span>
<span class="sd">            that is why they are normally used in routine operations</span>

<span class="sd">        By default the input type is assumed to be the same as the output type,</span>
<span class="sd">        except for *classification*, *feature_generation* and *type_conversion*.</span>
<span class="sd">        For any other algorithm type, especially for meta nodes,</span>
<span class="sd">        this method needs to be overwritten.</span>
<span class="sd">        Otherwise, a warning will occur.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;classification&quot;</span> <span class="ow">in</span> <span class="n">pack</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;PredictionVector&quot;</span>
        <span class="k">elif</span> <span class="s2">&quot;feature_generation&quot;</span> <span class="ow">in</span> <span class="n">pack</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;FeatureVector&quot;</span>
        <span class="k">elif</span> <span class="s2">&quot;type_conversion&quot;</span> <span class="ow">in</span> <span class="n">pack</span><span class="p">:</span>
            <span class="c1"># it is expected that nodes in the type_conversion script</span>
            <span class="c1"># overwrite this method with their specific output types</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_string</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string_to_class</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BaseNode.string_to_class"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.string_to_class">[docs]</a>    <span class="k">def</span> <span class="nf">string_to_class</span><span class="p">(</span><span class="n">string_encoding</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; given a string variable, outputs a class instance</span>

<span class="sd">        e.g., obtaining a TimeSeries</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; result = BaseNode.string_to_class(&quot;TimeSeries&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print type(result)</span>
<span class="sd">            &lt;class &#39;pySPACE.resources.data_types.time_series.TimeSeries&#39;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pySPACE.resources.data_types.time_series</span> <span class="kn">import</span> <span class="n">TimeSeries</span>
        <span class="kn">from</span> <span class="nn">pySPACE.resources.data_types.feature_vector</span> <span class="kn">import</span> <span class="n">FeatureVector</span>
        <span class="kn">from</span> <span class="nn">pySPACE.resources.data_types.prediction_vector</span> \
            <span class="kn">import</span> <span class="n">PredictionVector</span>
        <span class="k">if</span> <span class="s2">&quot;TimeSeries&quot;</span> <span class="ow">in</span> <span class="n">string_encoding</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TimeSeries</span>
        <span class="k">elif</span> <span class="s2">&quot;PredictionVector&quot;</span> <span class="ow">in</span> <span class="n">string_encoding</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PredictionVector</span>
        <span class="k">elif</span> <span class="s2">&quot;FeatureVector&quot;</span> <span class="ow">in</span> <span class="n">string_encoding</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FeatureVector</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="c1">###### Reimplementation of some MDP methods that have some flaws, ######</span>
    <span class="c1">###### when used with the different concepts, used here.          ######</span>
    <span class="c1">### check functions</span>
<div class="viewcode-block" id="BaseNode._check_input"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._check_input">[docs]</a>    <span class="k">def</span> <span class="nf">_check_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check the input_dim and array consistency</span>

<span class="sd">        Here input_dim are the dimensions of the input array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="c1"># check input type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_input_types</span><span class="p">():</span>
            <span class="c1"># self._log(&quot;Data type (%s) not supported by %s?&quot; %</span>
            <span class="c1">#           (type(x).__name__, self.__class__.__name__),</span>
            <span class="c1">#           level=logging.CRITICAL)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Data type (</span><span class="si">%s</span><span class="s2">) not supported by </span><span class="si">%s</span><span class="s2">?&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="c1"># raise NotImplementedError</span>
        <span class="c1"># check input rank</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">error_str</span> <span class="o">=</span> <span class="s2">&quot;Class </span><span class="si">%s</span><span class="s2">: x has rank </span><span class="si">%d</span><span class="s2">, should be 2&quot;</span> \
                            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">NodeException</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span>
        <span class="c1"># check for NaN</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data_array</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">error_str</span> <span class="o">=</span> <span class="s2">&quot;Class </span><span class="si">%s</span><span class="s2">: Not finite number in data: </span><span class="si">%s</span><span class="s2">!&quot;</span> \
                            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">data_array</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">NodeException</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span>
        <span class="c1"># set the dtype if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># check if the user has changed the dtype of the input</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The dtype of individual data points is &quot;</span> <span class="o">+</span>
                          <span class="s2">&quot;inconsistent.</span><span class="se">\n</span><span class="s2"> The former data type was &quot;</span> <span class="o">+</span>
                          <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">) and now the input is (</span><span class="si">%s</span><span class="s2">)&quot;</span>
                          <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span>
        <span class="c1"># set the input dimension if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="o">=</span><span class="n">shape</span>
        <span class="c1"># in case of homogenous data control the dimension x</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">homogenous</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">:</span>
                <span class="n">error_str</span> <span class="o">=</span> <span class="s2">&quot;Class </span><span class="si">%s</span><span class="s2">: x has dimension </span><span class="si">%s</span><span class="s2">, should be </span><span class="si">%s</span><span class="s2">&quot;</span> \
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">))</span>
                <span class="k">raise</span> <span class="n">NodeException</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span></div>

    <span class="c1">### Handle the data types of the data</span>
<div class="viewcode-block" id="BaseNode._get_supported_dtypes"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._get_supported_dtypes">[docs]</a>    <span class="k">def</span> <span class="nf">_get_supported_dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the list of dtypes supported by this node.</span>

<span class="sd">        The types can be specified in any format allowed by *numpy* `dtype`.</span>

<span class="sd">        .. todo:: In future we should use as default float and double</span>
<span class="sd">                    and specify explicitly for each node</span>
<span class="sd">                    if it can use other input formats!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_dtypes</span><span class="p">(</span><span class="n">typecodes_key</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return the list of dtypes corresponding to the set of</span>
<span class="sd">            typecodes defined in numpy.typecodes[typecodes_key].</span>
<span class="sd">            E.g., get_dtypes(&#39;Float&#39;) = [dtype(&#39;f&#39;), dtype(&#39;d&#39;), dtype(&#39;g&#39;)].</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="n">typecodes_key</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">types</span>

        <span class="k">return</span> <span class="n">get_dtypes</span><span class="p">(</span><span class="s1">&#39;All&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.get_dtype"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_dtype">[docs]</a>    <span class="k">def</span> <span class="nf">get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return dtype.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span></div>

<div class="viewcode-block" id="BaseNode.set_dtype"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.set_dtype">[docs]</a>    <span class="k">def</span> <span class="nf">set_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set internal structures&#39; dtype.</span>

<span class="sd">        Perform sanity checks and then calls `self._set_dtype(n)`, which</span>
<span class="sd">        is responsible for setting the internal attribute `self._dtype`.</span>

<span class="sd">        .. note:: Subclasses should overwrite self._set_dtype when needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Difference to MDP&#39;s standard set_dtype: Setting of dtypes allows</span>
        <span class="c1"># now also dtypes that are inherited from supported dtypes</span>
        <span class="c1"># (in order to allow for var-length strings)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">!=</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Class </span><span class="si">%s</span><span class="s2">: dtype is already set to &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                      <span class="s2">&quot;(&#39;</span><span class="si">%s</span><span class="s2">&#39; given)!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_supported_dtypes</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_dtype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">dtype &#39;</span><span class="si">%s</span><span class="s2">&#39; is not supported.</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="s2">&quot;Supported dtypes: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">get_supported_dtypes</span><span class="p">()]))</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode._set_dtype"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._set_dtype">[docs]</a>    <span class="k">def</span> <span class="nf">_set_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_supported_dtypes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">NodeException</span><span class="p">(</span>
                <span class="s1">&#39;dtype </span><span class="si">%s</span><span class="s1"> not among supported dtypes (</span><span class="si">%s</span><span class="s1">) in node </span><span class="si">%s</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_supported_dtypes</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">t</span></div>

<div class="viewcode-block" id="BaseNode.get_supported_dtypes"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_supported_dtypes">[docs]</a>    <span class="k">def</span> <span class="nf">get_supported_dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dtypes supported by the node as a list of numpy `dtype` objects.</span>

<span class="sd">        Note that subclasses should overwrite `self._get_supported_dtypes`</span>
<span class="sd">        when needed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_supported_dtypes</span><span class="p">()]</span></div>

    <span class="n">supported_dtypes</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_supported_dtypes</span><span class="p">,</span>
                                <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Supported dtypes&quot;</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_dtype</span><span class="p">,</span>
                     <span class="n">set_dtype</span><span class="p">,</span>
                     <span class="n">doc</span> <span class="o">=</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span>
    <span class="c1">################ Reimplementation END ################</span>


    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BaseNode.node_from_yaml"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.node_from_yaml">[docs]</a>    <span class="k">def</span> <span class="nf">node_from_yaml</span><span class="p">(</span><span class="n">node_spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a node based on the dictionary *node_spec* &quot;&quot;&quot;</span>
        <span class="c1"># The node_spec from the calling method should not be changed,</span>
        <span class="c1"># hence there are maybe several recalls with the same node_spec</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">node_spec</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span> <span class="ow">and</span> <span class="s2">&quot;node&quot;</span> <span class="ow">in</span> <span class="n">node_spec</span><span class="p">),</span> \
            <span class="s2">&quot;Error in node spec. (no dict or no &#39;node&#39; key): &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">node_spec</span>
        <span class="n">node_spec</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">node_spec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_spec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Maybe you have a wrong minus with no following &quot;</span>
                          <span class="s2">&quot;entry in your spec file? Please correct and &quot;</span>
                          <span class="s2">&quot;restart!&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># evaluation of components of the form &quot;eval(command)&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_spec</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">],</span> <span class="nb">basestring</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="n">node_spec</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;eval(&quot;</span><span class="p">):</span>
            <span class="n">node_name</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">node_spec</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">][</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_name</span> <span class="o">=</span> <span class="n">node_spec</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">node_class</span> <span class="o">=</span> <span class="n">pySPACE</span><span class="o">.</span><span class="n">missions</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">NODE_MAPPING</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">UserWarning</span><span class="p">(</span><span class="s2">&quot;No node with name </span><span class="si">%s</span><span class="s2"> exists&quot;</span> <span class="o">%</span> <span class="n">node_name</span><span class="p">)</span>

        <span class="c1"># If the node overwrites this method we delegate node creation</span>
        <span class="k">if</span> <span class="n">node_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Noop&#39;</span><span class="p">,</span> <span class="s2">&quot;Base&quot;</span><span class="p">,</span> <span class="s2">&quot;BaseNode&quot;</span><span class="p">]</span> <span class="ow">and</span> \
                <span class="s1">&#39;node_from_yaml&#39;</span> <span class="ow">in</span> <span class="n">node_class</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node_class</span><span class="o">.</span><span class="n">node_from_yaml</span><span class="p">(</span><span class="n">node_spec</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node_class</span><span class="o">.</span><span class="n">__module__</span> <span class="o">==</span> <span class="s2">&quot;pySPACE.missions.nodes.external&quot;</span><span class="p">:</span>
            <span class="c1"># do not interface the wrapper but the real class</span>
            <span class="k">if</span> <span class="s1">&#39;node_from_yaml&#39;</span> <span class="ow">in</span> <span class="n">node_class</span><span class="o">.</span><span class="n">__bases__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node_class</span><span class="o">.</span><span class="n">node_from_yaml</span><span class="p">(</span><span class="n">node_spec</span><span class="p">)</span>

        <span class="c1"># If parameters need to be passed to the class</span>
        <span class="k">if</span> <span class="s2">&quot;parameters&quot;</span> <span class="ow">in</span> <span class="n">node_spec</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node_spec</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No parameters specified for </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="n">node_name</span><span class="p">)</span>
                <span class="n">node_obj</span> <span class="o">=</span> <span class="n">node_class</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># All parameters which are eval() statements</span>
                <span class="c1"># are considered to be python expressions and are evaluated</span>
                <span class="n">BaseNode</span><span class="o">.</span><span class="n">eval_dict</span><span class="p">(</span><span class="n">node_spec</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">])</span>
                <span class="c1"># Create the node object</span>
            <span class="c1">#try:</span>
                <span class="n">node_obj</span> <span class="o">=</span> <span class="n">node_class</span><span class="p">(</span><span class="o">**</span><span class="n">node_spec</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">])</span>
            <span class="c1">#except TypeError, e:</span>
                <span class="c1">#raise TypeError(&quot;%s: %s&quot; % (node_class.__name__, e))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_obj</span> <span class="o">=</span> <span class="n">node_class</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">node_obj</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BaseNode.eval_dict"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.eval_dict">[docs]</a>    <span class="k">def</span> <span class="nf">eval_dict</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check dictionary entries starts and evaluate if needed</span>

<span class="sd">        Evaluation is switched on, by using ``eval(statement)`` to</span>
<span class="sd">        evaluate the *statement*.</span>
<span class="sd">        Dictionary entries are replaced with evaluation result.</span>

<span class="sd">        .. note:: No additional string mark up needed, contrary to normal</span>
<span class="sd">                python evaluate syntax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;eval(&quot;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">BaseException</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Could not evaluate:&quot;</span><span class="o">+</span><span class="n">value</span><span class="o">+</span><span class="s2">&quot;. Error:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseNode.set_permanent_attributes"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.set_permanent_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">set_permanent_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add all the items of the given kwargs dictionary as permanent attributes of this object</span>

<span class="sd">        Permanent attribute are reset, when using the reset method.</span>
<span class="sd">        The other attributes are deleted.</span>

<span class="sd">        .. note:: Parameters of the basic init function are always set permanent.</span>
<span class="sd">        .. note:: The memory of permanent attributes is doubled.</span>
<span class="sd">                  When having large objects, like the data in source nodes,</span>
<span class="sd">                  you should handle this by overwriting the reset method.</span>

<span class="sd">        The main reason for this method is the reset of nodes during cross</span>
<span class="sd">        validation. Here the parameters of the algorithms have to be reset,</span>
<span class="sd">        to have independent evaluations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Deepcopy the permanent state (except the input node and generator)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;input_node&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;generator&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># Track changes in node_specs. This is a dictionary with all local</span>
        <span class="c1"># variables of the __init__ function.</span>
        <span class="c1"># The variable names can be found with the co_varnames attribute</span>
        <span class="c1"># of the function object code object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_specs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="o">.</span><span class="n">im_func</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_specs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;node_name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_name</span><span class="p">})</span></div>

<div class="viewcode-block" id="BaseNode.reset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the state of the object to the clean state it had after its initialization</span>

<span class="sd">        .. note:: Attributes in the permanent state are not overwritten/reset.</span>
<span class="sd">                  Parameters were set into permanent state with the method:</span>
<span class="sd">                  *set_permanent_attributes*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We have to create a temporary reference since we remove</span>
        <span class="c1"># the self.permanent_state reference in the next step by overwriting</span>
        <span class="c1"># self.__dict__</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span>
        <span class="c1"># The input node should not be deepcopied since otherwise the input</span>
        <span class="c1"># node and the node in the node list that precedes this node are</span>
        <span class="c1"># different objects</span>
        <span class="n">input_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;input_node&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span> <span class="o">=</span> <span class="n">input_node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span><span class="p">[</span><span class="s2">&quot;input_node&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_node</span></div>

<div class="viewcode-block" id="BaseNode.reset_attribute"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.reset_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">reset_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset a single attribute with its previously saved permanent state &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attribute_string</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;You did not use a string for reset.&quot;</span><span class="o">+</span>
                          <span class="s2">&quot;Instead you used:</span><span class="si">%s</span><span class="s2">.&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">attribute_string</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">attribute_string</span><span class="p">]</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span><span class="p">[</span><span class="n">attribute_string</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;You did not use a valid attribute for reset.&quot;</span><span class="o">+</span>
                          <span class="s2">&quot;Instead you used:</span><span class="si">%s</span><span class="s2">.&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">attribute_string</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseNode.is_retrainable"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.is_retrainable">[docs]</a>    <span class="k">def</span> <span class="nf">is_retrainable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns if node supports retraining &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrainable</span></div>

<div class="viewcode-block" id="BaseNode.is_source_node"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.is_source_node">[docs]</a>    <span class="k">def</span> <span class="nf">is_source_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns whether this node is a source node that can yield data &quot;&quot;&quot;</span>
        <span class="c1"># A source node is identified by its name ending</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;SourceNode&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.is_sink_node"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.is_sink_node">[docs]</a>    <span class="k">def</span> <span class="nf">is_sink_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns if this node is a sink node that gathers results&quot;&quot;&quot;</span>
        <span class="c1"># A sink node is identified by its property of having a method</span>
        <span class="c1"># with the name &quot;store_results&quot;</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;get_result_dataset&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.is_split_node"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.is_split_node">[docs]</a>    <span class="k">def</span> <span class="nf">is_split_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns whether this is a split node. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="BaseNode.register_input_node"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.register_input_node">[docs]</a>    <span class="k">def</span> <span class="nf">register_input_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Register the given node as input &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">input_node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.set_run_number"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.set_run_number">[docs]</a>    <span class="k">def</span> <span class="nf">set_run_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Informs the node about the number of the current run</span>

<span class="sd">        Per default, a node is not interested in the run number and simply</span>
<span class="sd">        hands the information back to its input node.</span>
<span class="sd">        For nodes like splitter that are interested in the run_number, this method</span>
<span class="sd">        can be overwritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">run_number</span><span class="o">=</span><span class="n">run_number</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_source_node</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">set_run_number</span><span class="p">(</span><span class="n">run_number</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.set_temp_dir"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.set_temp_dir">[docs]</a>    <span class="k">def</span> <span class="nf">set_temp_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temp_dir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Give directory name for temporary data saves &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">temp_dir</span> <span class="o">=</span> <span class="n">temp_dir</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">set_temp_dir</span><span class="p">(</span><span class="n">temp_dir</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="BaseNode.get_source_file_name"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_source_file_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_source_file_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the name of the source file.</span>

<span class="sd">        This works for the Stream2TimeSeriesSourceNode.</span>
<span class="sd">        For other nodes None is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">get_source_file_name</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="BaseNode.perform_final_split_action"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.perform_final_split_action">[docs]</a>    <span class="k">def</span> <span class="nf">perform_final_split_action</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform automatic action when the processing of the current split is finished.</span>

<span class="sd">        This method does nothing in the default case, but can be overwritten by child nodes if desired.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="BaseNode.use_next_split"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.use_next_split">[docs]</a>    <span class="k">def</span> <span class="nf">use_next_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Use the next split of the data into training and test data.</span>

<span class="sd">        Returns True if more splits are available, otherwise False.</span>

<span class="sd">        This method is useful for benchmarking</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_node</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">)</span>

        <span class="n">has_more_splits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">use_next_split</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perform_final_split_action</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">has_more_splits</span><span class="p">:</span>
            <span class="c1"># Counting the number of the current split</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">increase_split_number</span><span class="p">()</span>
            <span class="c1"># Resetting the node for the next run</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">has_more_splits</span></div>

<div class="viewcode-block" id="BaseNode.increase_split_number"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.increase_split_number">[docs]</a>    <span class="k">def</span> <span class="nf">increase_split_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Method for increasing split number (needed for access by meta nodes)</span>

<span class="sd">        .. todo:: Better exception handling. Move code to meta/Layer nodes?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">current_split</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_split</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">increase_split_number</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">increase_split_number</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="BaseNode._get_train_set"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._get_train_set">[docs]</a>    <span class="k">def</span> <span class="nf">_get_train_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_test_data</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the data that can be used for training &quot;&quot;&quot;</span>
        <span class="c1"># We take data that is provided by the input node for training</span>
        <span class="c1"># NOTE: This might involve training of the preceding nodes</span>
        <span class="n">train_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">request_data_for_training</span><span class="p">(</span><span class="n">use_test_data</span><span class="p">)</span>
        <span class="c1"># If we should also use the test data for training (i.e. we are not</span>
        <span class="c1"># doing benchmarking...)</span>
        <span class="k">if</span> <span class="n">use_test_data</span><span class="p">:</span>
            <span class="c1"># Add the data provided by the input node for testing to the</span>
            <span class="c1"># training set</span>
            <span class="n">train_set</span> <span class="o">=</span> \
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">request_data_for_testing</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">train_set</span></div>

<div class="viewcode-block" id="BaseNode.train_sweep"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.train_sweep">[docs]</a>    <span class="k">def</span> <span class="nf">train_sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_test_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Performs the actual training of the node.</span>

<span class="sd">        If use_test_data is True, we use all available data for training,</span>
<span class="sd">        otherwise only the data that is explicitly marked as data for training.</span>
<span class="sd">        This is a requirement e.g. for benchmarking.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this node does not require training</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_training</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Does not require training.&quot;</span><span class="p">)</span>
        <span class="c1"># Check whether the node requires supervised training</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_supervised</span><span class="p">():</span> <span class="c1"># Supervised learning</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Supervised training started.&quot;</span><span class="p">)</span>
            <span class="c1"># For all train phases</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Supervised train stage </span><span class="si">%s</span><span class="s2"> started.&quot;</span>
                                            <span class="o">%</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span><span class="p">)</span>
                <span class="n">train_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_train_set</span><span class="p">(</span><span class="n">use_test_data</span><span class="p">)</span>
                <span class="c1"># Present all available data (along with the corresponding</span>
                <span class="c1"># label) to this node</span>
                <span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">train_set</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="c1"># Stop this train phase</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stop_training</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Supervised train stage </span><span class="si">%s</span><span class="s2"> finished.&quot;</span>
                                                         <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Supervised training finished.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">():</span> <span class="c1"># Unsupervised learning</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Unsupervised training started.&quot;</span><span class="p">)</span>
            <span class="n">train_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_train_set</span><span class="p">(</span><span class="n">use_test_data</span><span class="p">)</span>
            <span class="c1"># For all train phases</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Unsupervised train stage </span><span class="si">%s</span><span class="s2"> started.&quot;</span>
                                        <span class="o">%</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span><span class="p">)</span>
                <span class="c1"># Present all available data to this node, but</span>
                <span class="c1"># skip the label (since we are doing unsupervised training)</span>
                <span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">train_set</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Unsupervised train stage </span><span class="si">%s</span><span class="s2"> finished.&quot;</span>
                                         <span class="o">%</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span><span class="p">)</span>
                <span class="c1"># Stop this train phase</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stop_training</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Unsupervised training finished.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.process"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Processes all data that is provided by the input node</span>

<span class="sd">        Returns a generator that yields the data after being processed by this</span>
<span class="sd">        node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_node</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">),</span> <span class="s2">&quot;No input node specified!&quot;</span>
        <span class="c1"># Assert  that this node has already been trained</span>
        <span class="k">assert</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">()</span> <span class="ow">or</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;Node not trained!&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Processing data.&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">data_generator</span> <span class="o">=</span> \
                <span class="n">itertools</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
                      <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trace</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;entry&quot;</span><span class="p">)),</span>
                                   <span class="s2">&quot;exit&quot;</span><span class="p">),</span> <span class="n">label</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">process</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">data_generator</span></div>

<div class="viewcode-block" id="BaseNode.request_data_for_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.request_data_for_training">[docs]</a>    <span class="k">def</span> <span class="nf">request_data_for_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_test_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns data for training of subsequent nodes of the node chain</span>

<span class="sd">        A call to this method might involve training of the node chain up this</span>
<span class="sd">        node. If use_test_data is true, all available data is used for</span>
<span class="sd">        training, otherwise only the data that is explicitly for training.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_node</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Data for training is requested.&quot;</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

        <span class="c1"># If we haven&#39;t computed the data for training yet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_for_training</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Producing data for training.&quot;</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
            <span class="c1"># Train this node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_sweep</span><span class="p">(</span><span class="n">use_test_data</span><span class="p">)</span>
            <span class="c1"># Compute a generator the yields the train data and</span>
            <span class="c1"># encapsulate it in an object that memoizes its outputs and</span>
            <span class="c1"># provides a &quot;fresh&quot; method that returns a new generator that&#39;ll</span>
            <span class="c1"># yield the same sequence</span>
            <span class="c1"># This line crashes without the NodeMetaclass bug fix</span>
            <span class="n">train_data_generator</span> <span class="o">=</span> \
                 <span class="n">itertools</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="p">:</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">in_training</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">label</span><span class="p">),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">request_data_for_training</span><span class="p">(</span>
                                                                <span class="n">use_test_data</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_for_training</span> <span class="o">=</span> <span class="n">MemoizeGenerator</span><span class="p">(</span><span class="n">train_data_generator</span><span class="p">,</span>
                                                      <span class="n">caching</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caching</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Data for training finished&quot;</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="c1"># Return a fresh copy of the generator</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_for_training</span><span class="o">.</span><span class="n">fresh</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseNode.request_data_for_testing"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.request_data_for_testing">[docs]</a>    <span class="k">def</span> <span class="nf">request_data_for_testing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns data for testing of subsequent nodes of the node chain</span>

<span class="sd">        A call to this node might involve evaluating the whole node chain</span>
<span class="sd">        up to this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_node</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Data for testing is requested.&quot;</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

        <span class="c1"># If we haven&#39;t computed the data for testing yet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_for_testing</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Assert  that this node has already been trained</span>
            <span class="k">assert</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">()</span> <span class="ow">or</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Compute a generator the yields the test data and</span>
            <span class="c1"># encapsulate it in an object that memoizes its outputs and</span>
            <span class="c1"># provides a &quot;fresh&quot; method that returns a new generator that&#39;ll</span>
            <span class="c1"># yield the same sequence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Producing data for testing.&quot;</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
            <span class="n">test_data_generator</span> <span class="o">=</span> \
                <span class="n">itertools</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">test_retrain</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">request_data_for_testing</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_for_testing</span> <span class="o">=</span> <span class="n">MemoizeGenerator</span><span class="p">(</span><span class="n">test_data_generator</span><span class="p">,</span>
                                                     <span class="n">caching</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caching</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Data for testing finished&quot;</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="c1"># Return a fresh copy of the generator</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_for_testing</span><span class="o">.</span><span class="n">fresh</span><span class="p">()</span></div>


<div class="viewcode-block" id="BaseNode.test_retrain"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.test_retrain">[docs]</a>    <span class="k">def</span> <span class="nf">test_retrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Wrapper method for offline incremental retraining</span>

<span class="sd">        The parameter *retrain* has to be set to True to activate offline retraining.</span>
<span class="sd">        The parameter *buffering* should be False, which is the default.</span>

<span class="sd">        .. note:: The execute method of the node is called implicitly</span>
<span class="sd">                  in this node instead of being called in the</span>
<span class="sd">                  request_data_for_testing-method.</span>
<span class="sd">                  For the incremental retraining itself</span>
<span class="sd">                  the method _inc_train (to be implemented)</span>
<span class="sd">                  is called.</span>

<span class="sd">        For programming, we first train on the old data and then execute</span>
<span class="sd">        on the new one. This is necessary, since the following nodes</span>
<span class="sd">        may need the status of the transformation.</span>
<span class="sd">        So we must not change it after calling execute.</span>

<span class="sd">        .. note :: Currently there is no retraining to the last sample.</span>
<span class="sd">                      This could be done by modifying the :func:`present_label`</span>
<span class="sd">                      method and calling  it in the last node after the</span>
<span class="sd">                      last sample was processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_retrainable</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffering</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_inc_train&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">retraining_phase</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">retraining_phase</span><span class="o">=</span><span class="bp">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_retraining</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inc_train</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">retrain_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">retrain_label</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">retrain_data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">retrain_label</span> <span class="o">=</span> <span class="n">label</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.start_retraining"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.start_retraining">[docs]</a>    <span class="k">def</span> <span class="nf">start_retraining</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Method called for initialization of retraining &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="BaseNode.present_label"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.present_label">[docs]</a>    <span class="k">def</span> <span class="nf">present_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Wrapper method for incremental training in application case (live)</span>

<span class="sd">        The parameters *retrain* and *buffering* have to be</span>
<span class="sd">        set to True to activate this functionality.</span>

<span class="sd">        For skipping examples, you can use None, &quot;null&quot; or an empty string as label.</span>

<span class="sd">        .. note:: For the incremental training itself</span>
<span class="sd">                  the method _inc_train (to be implemented)</span>
<span class="sd">                  is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">present_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffering</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_retrainable</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">retraining_phase</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">retraining_phase</span><span class="o">=</span><span class="bp">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_retraining</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;null&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_inc_train</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">label</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_batch_retrain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)],</span><span class="n">label</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode._batch_retrain"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._batch_retrain">[docs]</a>    <span class="k">def</span> <span class="nf">_batch_retrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data_list</span><span class="p">,</span> <span class="n">label_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Interface for retraining with a set of data</span>

<span class="sd">        A possible application is a calibration phase, where we may want to</span>
<span class="sd">        improve non-incremental algorithms.</span>

<span class="sd">        If this method is not overwritten, it uses the incremental training</span>
<span class="sd">        as a default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">label_list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inc_train</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">label_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">data_list</span>  <span class="o">=</span> <span class="bp">None</span>
        <span class="n">label_list</span> <span class="o">=</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="BaseNode._change_parameters"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._change_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">_change_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Overwrite parameters of a node e.g. when it is loaded and</span>
<span class="sd">        parameters like *retrain* or *recalibrate* have to be set to True.</span>

<span class="sd">        The node only provides the simple straight forward way,</span>
<span class="sd">        of permanently replacing the parameters.</span>
<span class="sd">        For more sophisticated parameter handling, nodes have to replace this</span>
<span class="sd">        method by their own.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.store_state"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.store_state">[docs]</a>    <span class="k">def</span> <span class="nf">store_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_dir</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Stores this node in the given directory *result_dir*</span>

<span class="sd">        This method is automatically called during benchmarking</span>
<span class="sd">        for every node.</span>
<span class="sd">        The standard convention is, that nodes only store their state,</span>
<span class="sd">        if the parameter *store* in the specification is set *True*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">format_dict</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">),</span> <span class="n">BaseNode</span><span class="p">):</span>
                    <span class="c1"># the item is a nested pyspace node -&gt; get dictionary and clean it</span>
                    <span class="n">attr_dict</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
                    <span class="n">attr_dict</span> <span class="o">=</span> <span class="n">format_dict</span><span class="p">(</span><span class="n">attr_dict</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">attr_dict</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># the item is a attribute dict -&gt; remove inappropriate value</span>
                <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s1">&#39;input_node&#39;</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">item</span><span class="p">[</span><span class="s1">&#39;input_node&#39;</span><span class="p">]</span> 
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">format_dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>    
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subitem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">subitem</span><span class="p">),</span> <span class="n">BaseNode</span><span class="p">):</span>
                                <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_dict</span><span class="p">(</span><span class="n">subitem</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subitem</span><span class="p">)</span>
                        <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
                    <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span> <span class="n">new_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the item is a primitive type</span>
                <span class="k">return</span> <span class="n">item</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">scipy.io</span>
            <span class="n">node_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">result_file</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="c1"># export to text file </span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">result_file</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_index</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;.mat&quot;</span><span class="p">):</span>
                    <span class="n">node_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="n">result_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;.mat&quot;</span><span class="p">,</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
            <span class="n">attr_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
            <span class="c1"># matlab doesn&#39;t like Nones.. replace Nones with 0&#39;s</span>
            <span class="n">attr_dict</span> <span class="o">=</span> <span class="n">format_dict</span><span class="p">(</span><span class="n">attr_dict</span><span class="p">)</span>
            
            <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="n">result_file</span><span class="p">,</span> <span class="n">mdict</span><span class="o">=</span><span class="n">attr_dict</span><span class="p">)</span></div>
            

<div class="viewcode-block" id="BaseNode._log"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._log">[docs]</a>    <span class="k">def</span> <span class="nf">_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Log the given message into the logger of this class &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pySPACE</span><span class="o">.</span><span class="n">configuration</span><span class="o">.</span><span class="n">min_log_level</span><span class="o">&gt;</span><span class="n">level</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;root_logger&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">(),</span>
                                                               <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span>
                                                               <span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">SocketHandler</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">DEFAULT_TCP_LOGGING_PORT</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.__del__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.__del__">[docs]</a>    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Stop logging</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;root_logger&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span><span class="o">.</span><span class="n">removeHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_logger</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode._trace"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._trace">[docs]</a>    <span class="k">def</span> <span class="nf">_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">key_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Every call of this function creates a time-stamped log entry &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> time: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key_str</span> <span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="BaseNode.__getstate__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.__getstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a pickable state for this object &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Pickling instance of class </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                  <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">odict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># copy the dict since we change it</span>
        <span class="n">odict</span><span class="p">[</span><span class="s1">&#39;data_for_training&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">odict</span><span class="p">[</span><span class="s1">&#39;data_for_testing&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">odict</span><span class="p">[</span><span class="s1">&#39;root_logger&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="s2">&quot;data&quot;</span> <span class="ow">in</span> <span class="n">odict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_split_node</span><span class="p">():</span>
            <span class="n">odict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;generator&quot;</span> <span class="ow">in</span> <span class="n">odict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">odict</span><span class="p">[</span><span class="s2">&quot;generator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">odict</span><span class="p">[</span><span class="s1">&#39;permanent_state&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c1">#del odict[&#39;permanent_state&#39;]</span>
        <span class="c1"># Remove other non-pickable stuff</span>
        <span class="n">remove_keys</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">odict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;input_node&quot;</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;flow&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">PicklingError</span><span class="p">):</span>
                <span class="n">remove_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">remove_keys</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Removing attribute </span><span class="si">%s</span><span class="s2"> of class </span><span class="si">%s</span><span class="s2"> (type </span><span class="si">%s</span><span class="s2">) because of &quot;</span>
                      <span class="s2">&quot;it can not be pickled.&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">odict</span><span class="p">[</span><span class="n">key</span><span class="p">])),</span>
                       <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
            <span class="n">odict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">odict</span></div>

<div class="viewcode-block" id="BaseNode.__setstate__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.__setstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sdict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Restore object from its pickled state&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Restoring instance of class </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                  <span class="n">level</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sdict</span><span class="p">)</span>   <span class="c1"># update attributes</span>
        <span class="c1"># Reconstruct the permanent state of the object</span>
        <span class="c1"># This should be a deepcopy except for the input node...</span>
        <span class="k">if</span> <span class="s2">&quot;input_node&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="n">input_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;input_node&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s2">&quot;input_node&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span><span class="p">[</span><span class="s1">&#39;input_node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">permanent_state</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.replace_keywords_in_load_path"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.replace_keywords_in_load_path">[docs]</a>    <span class="k">def</span> <span class="nf">replace_keywords_in_load_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Replace keywords in the load_path parameter</span>

<span class="sd">        .. note::</span>
<span class="sd">            The keywords **__INPUT_DATASET__** and **__RESULT_DIRECTORY__** can</span>
<span class="sd">            also be used. The replacement of these keyword is done by</span>
<span class="sd">            the :class:`~pySPACE.missions.operations.node_chain.NodeChainOperation`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;__SPLIT__&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;__RUN__&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_number</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.get_previous_transformations"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_previous_transformations">[docs]</a>    <span class="k">def</span> <span class="nf">get_previous_transformations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Recursively construct a list of (linear) transformations</span>

<span class="sd">        These transformations, applied on the data are needed later on for</span>
<span class="sd">        visualization. So the new classifier can be visualized relative</span>
<span class="sd">        to a previous linear processing step.</span>

<span class="sd">        .. todo:: Check if splitter node works together with this node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_source_node</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">get_previous_transformations</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
            <span class="n">own_transformation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_own_transformation</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">own_transformation</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># generic extraction of transformation for meta nodes</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;flow&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
                        <span class="n">own_transformations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_previous_transformations</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                        <span class="n">transformations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">own_transformations</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">transformations</span>
                    <span class="k">elif</span> <span class="s2">&quot;nodes&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
                        <span class="n">own_transformations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_previous_transformations</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                        <span class="n">transformations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">own_transformations</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">transformations</span>
                    <span class="k">elif</span> <span class="s2">&quot;node&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
                        <span class="n">own_transformation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">get_own_transformation</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">own_transformation</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">transformations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">own_transformation</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">transformations</span></div>

<div class="viewcode-block" id="BaseNode.get_previous_execute"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_previous_execute">[docs]</a>    <span class="k">def</span> <span class="nf">get_previous_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get execution from previous nodes on *data*</span>

<span class="sd">        *data* should be forwarded to the previous *number* input nodes and the</span>
<span class="sd">        the result should be returned. By default, the data is recursively</span>
<span class="sd">        executed from the source node.</span>

<span class="sd">        This function is needed for the implementation of the classifier</span>
<span class="sd">        application of the backtransformation concept, where the classifier</span>
<span class="sd">        function is kept in a state before transformation to track changes in</span>
<span class="sd">        the processing chain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_source_node</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">number</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;Index </span><span class="si">%s</span><span class="s2"> to large for recursive execute!&quot;</span> <span class="o">%</span> <span class="n">number</span><span class="p">,</span>
                        <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">_execute</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">number</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">_execute</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">get_previous_execute</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">number</span><span class="p">))</span></div>

    <span class="c1">### properties, copied from MDP without change</span>

<div class="viewcode-block" id="BaseNode.get_input_dim"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_input_dim">[docs]</a>    <span class="k">def</span> <span class="nf">get_input_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return input dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_dim</span></div>

<div class="viewcode-block" id="BaseNode.set_input_dim"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.set_input_dim">[docs]</a>    <span class="k">def</span> <span class="nf">set_input_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set input dimensions.</span>

<span class="sd">        Perform sanity checks and then calls ``self._set_input_dim(n)``, which</span>
<span class="sd">        is responsible for setting the internal attribute ``self._input_dim``.</span>
<span class="sd">        Note that subclasses should overwrite `self._set_input_dim`</span>
<span class="sd">        when needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_dim</span> <span class="o">!=</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Input dim are set already (</span><span class="si">%d</span><span class="s2">) &quot;</span>
                   <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2"> given) in node </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">InconsistentDimException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_dim</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode._set_input_dim"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._set_input_dim">[docs]</a>    <span class="k">def</span> <span class="nf">_set_input_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_dim</span> <span class="o">=</span> <span class="n">n</span></div>
        
    <span class="n">input_dim</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_input_dim</span><span class="p">,</span>
                         <span class="n">set_input_dim</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Input dimensions&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BaseNode.get_output_dim"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_output_dim">[docs]</a>    <span class="k">def</span> <span class="nf">get_output_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return output dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_dim</span></div>

<div class="viewcode-block" id="BaseNode.set_output_dim"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.set_output_dim">[docs]</a>    <span class="k">def</span> <span class="nf">set_output_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set output dimensions.</span>

<span class="sd">        Perform sanity checks and then calls ``self._set_output_dim(n)``, which</span>
<span class="sd">        is responsible for setting the internal attribute ``self._output_dim``.</span>
<span class="sd">        Note that subclasses should overwrite `self._set_output_dim`</span>
<span class="sd">        when needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_output_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_output_dim</span> <span class="o">!=</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Output dim are set already (</span><span class="si">%d</span><span class="s2">) &quot;</span>
                   <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2"> given) in node </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">InconsistentDimException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_dim</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode._set_output_dim"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._set_output_dim">[docs]</a>    <span class="k">def</span> <span class="nf">_set_output_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_dim</span> <span class="o">=</span> <span class="n">n</span></div>

    <span class="n">output_dim</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_output_dim</span><span class="p">,</span>
                          <span class="n">set_output_dim</span><span class="p">,</span>
                          <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Output dimensions&quot;</span><span class="p">)</span>

    <span class="c1">### Definition of training sequence from MDP</span>
    <span class="n">_train_seq</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_train_seq</span><span class="p">(),</span>
                          <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        List of tuples::</span>

<span class="s2">          [(training-phase1, stop-training-phase1),</span>
<span class="s2">           (training-phase2, stop_training-phase2),</span>
<span class="s2">           ...]</span>

<span class="s2">        By default::</span>

<span class="s2">          _train_seq = [(self._train, self._stop_training)]</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BaseNode._get_train_seq"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._get_train_seq">[docs]</a>    <span class="k">def</span> <span class="nf">_get_train_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span></div>

<div class="viewcode-block" id="BaseNode.has_multiple_training_phases"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.has_multiple_training_phases">[docs]</a>    <span class="k">def</span> <span class="nf">has_multiple_training_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the node has multiple training phases.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train_seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span></div>

    <span class="c1">### Node states from MDP</span>
<div class="viewcode-block" id="BaseNode.is_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.is_training">[docs]</a>    <span class="k">def</span> <span class="nf">is_training</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the node is in the training phase,</span>
<span class="sd">        False otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_training</span></div>

<div class="viewcode-block" id="BaseNode.get_current_train_phase"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_current_train_phase">[docs]</a>    <span class="k">def</span> <span class="nf">get_current_train_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index of the current training phase.</span>

<span class="sd">        The training phases are defined in the list `self._train_seq`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span></div>

<div class="viewcode-block" id="BaseNode.get_remaining_train_phase"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_remaining_train_phase">[docs]</a>    <span class="k">def</span> <span class="nf">get_remaining_train_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of training phases still to accomplish.</span>

<span class="sd">        If the node is not trainable then return 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train_seq</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

    <span class="c1">### check functions from mdp</span>
<div class="viewcode-block" id="BaseNode._check_output"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._check_output">[docs]</a>    <span class="k">def</span> <span class="nf">_check_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="c1"># check output rank</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">error_str</span> <span class="o">=</span> <span class="s2">&quot;y has rank </span><span class="si">%d</span><span class="s2">, should be 2 in node </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">NodeException</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span>

        <span class="c1"># check the output dimension</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">:</span>
            <span class="n">error_str</span> <span class="o">=</span> <span class="s2">&quot;y has dimension </span><span class="si">%d</span><span class="s2">, should be </span><span class="si">%d</span><span class="s2"> in node </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">NodeException</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode._if_training_stop_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._if_training_stop_training">[docs]</a>    <span class="k">def</span> <span class="nf">_if_training_stop_training</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_training</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stop_training</span><span class="p">()</span>
            <span class="c1"># if there is some training phases left we shouldn&#39;t be here!</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">error_str</span> <span class="o">=</span> <span class="s2">&quot;The training phases of node </span><span class="si">%s</span><span class="s2"> are not completed yet.&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
                <span class="k">raise</span> <span class="n">TrainingException</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode._pre_execution_checks"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._pre_execution_checks">[docs]</a>    <span class="k">def</span> <span class="nf">_pre_execution_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method contains all pre-execution checks.</span>

<span class="sd">        It can be used when a subclass defines multiple execution methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if training has not started yet, assume we want to train the node</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_current_train_phase</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase_started</span><span class="p">):</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stop_training</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_if_training_stop_training</span><span class="p">()</span>

        <span class="c1"># in case of homogenous data control the dimension x</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">homogenous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_input</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># set the output dimension if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span></div>

    <span class="c1">### casting helper functions from MDP</span>

<div class="viewcode-block" id="BaseNode._refcast"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode._refcast">[docs]</a>    <span class="k">def</span> <span class="nf">_refcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to cast arrays to the internal dtype.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">refcast</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Cast the array to dtype only if necessary, otherwise return a reference.</span>

<span class="sd">            .. todo:: move to tools?</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">array</span>
            <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">refcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

    <span class="c1">### User interface to the overwritten methods</span>
<div class="viewcode-block" id="BaseNode.execute"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">in_training</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Process the data contained in &#39;x&#39;</span>

<span class="sd">        If the object is still in the training phase, the function</span>
<span class="sd">        &#39;stop_training&#39; will be called.</span>
<span class="sd">        &#39;x&#39; is NOT a matrix having different variables on different columns</span>
<span class="sd">        and observations on the rows as in MDP.</span>
<span class="sd">        &#39;x&#39; is a data type object, which can be a TimeSeries,</span>
<span class="sd">        a FeatureVector or a PredictionVector.</span>

<span class="sd">        .. note:: This method changes the original MDP implementation.</span>
<span class="sd">                  The main difference to the MDP&#39;s standard execute method is</span>
<span class="sd">                  that here the output_dim of the node is set per default to</span>
<span class="sd">                  the size of the node&#39;s first result (and not to the size of</span>
<span class="sd">                  the input data). Furthermore we have a possible buffering</span>
<span class="sd">                  mode for retraining and suppress the setting of the dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># data buffering for training in live usage</span>
        <span class="c1"># needed for the delayed training, which is called</span>
        <span class="c1"># by the present_label method</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;buffering&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffering</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_training</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;data_buffer&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># no buffering in request_data_for_training</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_training_execution_phase</span> <span class="o">=</span> <span class="n">in_training</span>

        <span class="c1"># Additional feature, that standard keywords are replaced in the</span>
        <span class="c1"># loading path of the node.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replace_keywords_in_load_path</span><span class="p">()</span>

<span class="c1">#        # if training has not started yet, assume we want to train the node</span>
<span class="c1">#        # MDP-SPECIFIC CODE, WHICH SHOULD NOT BE USED ANYMORE</span>
<span class="c1">#        if (self.get_current_train_phase() == 0 and</span>
<span class="c1">#                                    not self._train_phase_started):</span>
<span class="c1">#            while True:</span>
<span class="c1">#                self.train(x)</span>
<span class="c1">#                if self.get_remaining_train_phase() &gt; 1:</span>
<span class="c1">#                    self.stop_training()</span>
<span class="c1">#                else:</span>
<span class="c1">#                    break</span>
<span class="c1">#</span>
<span class="c1">#        self._if_training_stop_training()</span>

        <span class="c1"># in case of homogenous data control the dimension x</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">homogenous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_input</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Do the actual computation</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_refcast</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># check output type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_output_type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">):</span>
            <span class="c1"># self._log(&quot;Inappropriate output %s to given input %s?&quot; %</span>
            <span class="c1">#          (self.get_output_type(type(x).__name__), type(x).__name__),</span>
            <span class="c1">#           level=logging.CRITICAL)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Inappropriate output </span><span class="si">%s</span><span class="s2"> to given input </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">?&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span> <span class="o">+</span>
                <span class="s2">&quot; Expected: </span><span class="si">%s</span><span class="s2">. &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_output_type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span> <span class="o">+</span>
                <span class="s2">&quot;Please check your node chain. &quot;</span> <span class="o">+</span>
                <span class="s2">&quot;Please provide a bug report if the respective node is &quot;</span> <span class="o">+</span>
                <span class="s2">&quot;expecting the wrong output.&quot;</span><span class="p">)</span>
        <span class="c1"># Make sure key, tag, specs and history are passed</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">has_meta</span><span class="p">():</span>
            <span class="n">result</span><span class="o">.</span><span class="n">inherit_meta_from</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">generate_meta</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_in_history</span><span class="p">:</span>
            <span class="c1"># Append current data to history</span>
            <span class="n">result</span><span class="o">.</span><span class="n">add_to_history</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_specs</span><span class="p">)</span>

        <span class="c1"># # set the dtype if necessary</span>
        <span class="c1"># if self.dtype is None:</span>
        <span class="c1">#     self.dtype = result.dtype</span>

        <span class="c1"># set the output dimension if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">homogenous</span><span class="p">:</span> 
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span> <span class="ow">in</span> <span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]):</span>
                <span class="n">error_str</span> <span class="o">=</span> <span class="s2">&quot;y has dimension </span><span class="si">%d</span><span class="s2">, should be </span><span class="si">%d</span><span class="s2"> in node </span><span class="si">%s</span><span class="s2">&quot;</span> \
                    <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="BaseNode.train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the internal structures according to the input data `x`.</span>

<span class="sd">        `x` is a matrix having different variables on different columns</span>
<span class="sd">        and observations on the rows.</span>

<span class="sd">        By default, subclasses should overwrite `_train` to implement their</span>
<span class="sd">        training phase. The docstring of the `_train` method overwrites this</span>
<span class="sd">        docstring.</span>

<span class="sd">        .. note::</span>
<span class="sd">            A subclass supporting multiple training phases should implement</span>
<span class="sd">            the *same* signature for all the training phases and document the</span>
<span class="sd">            meaning of the arguments in the `_train` method doc-string. Having</span>
<span class="sd">            consistent signatures is a requirement to use the node in a</span>
<span class="sd">            node chain.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">IsNotTrainableException</span><span class="p">(</span>
                <span class="s2">&quot;The node </span><span class="si">%s</span><span class="s2"> is not trainable.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_training</span><span class="p">():</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="s2">&quot;The training phase of node </span><span class="si">%s</span><span class="s2"> has already finished.&quot;</span> \
                <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
            <span class="k">raise</span> <span class="n">TrainingFinishedException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="c1"># in case of homogenous data control the dimension x</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">homogenous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_input</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_train_args</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase_started</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_seq</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span><span class="p">][</span><span class="mi">0</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">_refcast</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.stop_training"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.stop_training">[docs]</a>    <span class="k">def</span> <span class="nf">stop_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stop the training phase.</span>

<span class="sd">        By default, subclasses should overwrite `_stop_training` to implement</span>
<span class="sd">        this functionality. The docstring of the `_stop_training` method</span>
<span class="sd">        overwrites this docstring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_training</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase_started</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TrainingException</span><span class="p">(</span>
                <span class="s2">&quot;The node </span><span class="si">%s</span><span class="s2"> has not been trained. &quot;</span>
                <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span>
                <span class="s2">&quot;Check if you specified training data or a validation scheme&quot;</span> <span class="o">+</span>
                <span class="s2">&quot; (splitter). Furthermore you should check the node &quot;</span> <span class="o">+</span>
                <span class="s2">&quot;parameters. Did you specify relevant labels correct?&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_training</span><span class="p">():</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="s2">&quot;The training phase of node </span><span class="si">%s</span><span class="s2"> has already finished.&quot;</span>\
                <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
            <span class="k">raise</span> <span class="n">TrainingFinishedException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>

        <span class="c1"># close the current phase.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_seq</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span><span class="p">][</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_phase_started</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># check if we have some training phase left</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_training</span> <span class="o">=</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="BaseNode.__call__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling an instance of `Node` is equivalent to calling</span>
<span class="sd">        its `execute` method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">###### string representation</span>

<div class="viewcode-block" id="BaseNode.__str__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.__repr__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># print input_dim, output_dim, dtype</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="s2">&quot;input_dim=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;output_dim=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="s1">&#39;dtype=None&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="s2">&quot;dtype=&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
        <span class="n">args</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">inp</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">typ</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="n">args</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span></div>

<div class="viewcode-block" id="BaseNode.copy"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy of the node.</span>

<span class="sd">        :param protocol: the pickle protocol (deprecated).</span>

<span class="sd">        .. todo:: check if needed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">protocol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;protocol parameter to copy() is ignored&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.save"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save a pickled serialization of the node to `filename`.</span>
<span class="sd">        If `filename` is None, return a string.</span>

<span class="sd">        Note: the pickled `Node` is not guaranteed to be forwards or</span>
<span class="sd">        backwards compatible.</span>

<span class="sd">        .. todo:: check if needed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if protocol != 0 open the file in binary mode</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;wb&#39;</span> <span class="k">if</span> <span class="n">protocol</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;w&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">flh</span><span class="p">:</span>
                <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flh</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseNode.get_metadata"><a class="viewcode-back" href="../../../../api/generated/pySPACE.missions.nodes.base_node.html#pySPACE.missions.nodes.base_node.BaseNode.get_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span></div></div>
        


<span class="c1"># Specify special node names, different to standard names</span>
<span class="n">_NODE_MAPPING</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Noop&quot;</span><span class="p">:</span> <span class="n">BaseNode</span><span class="p">}</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pySPACE documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, pySPACE Developer Team.
      Last updated on Sep 04, 2016.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.2.
    </div>
  </body>
</html>