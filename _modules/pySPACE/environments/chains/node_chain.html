

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pySPACE.environments.chains.node_chain &mdash; pySPACE 1.0 release documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/pySPACE.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.0 release',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/pyspace-logo.ico"/>
    <link rel="top" title="pySPACE 1.0 release documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">pySPACE 1.0 release documentation</a> &raquo;</li>
          <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/pyspace-logo_small.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pySPACE.environments.chains.node_chain</h1><div class="highlight"><pre>
<span class="c"># coding=utf-8</span>
<span class="sd">&quot;&quot;&quot; NodeChains are sequential orders of :mod:`~pySPACE.missions.nodes`</span>

<span class="sd">.. image:: ../../graphics/node_chain.png</span>
<span class="sd">   :width: 500</span>

<span class="sd">There are two main use cases:</span>

<span class="sd">    * the application for :mod:`~pySPACE.run.launch_live` and the</span>
<span class="sd">        :mod:`~pySPACE.environments.live` using the default</span>
<span class="sd">        :class:`NodeChain` and</span>
<span class="sd">    * the benchmarking with :mod:`~pySPACE.run.launch` using</span>
<span class="sd">        the :class:`BenchmarkNodeChain` with the</span>
<span class="sd">        :mod:`~pySPACE.missions.operations.node_chain` operation.</span>

<span class="sd">.. seealso::</span>

<span class="sd">    - :mod:`~pySPACE.missions.nodes`</span>
<span class="sd">    - :ref:`node_list`</span>
<span class="sd">    - :mod:`~pySPACE.missions.operations.node_chain` operation</span>

<span class="sd">.. image:: ../../graphics/launch_live.png</span>
<span class="sd">   :width: 500</span>

<span class="sd">.. todo:: Documentation</span>

<span class="sd">This module extends/reimplements the original MDP flow class and</span>
<span class="sd">has some additional methods like reset(), save() etc.</span>

<span class="sd">Furthermore it supports the construction of NodeChains and</span>
<span class="sd">also running them inside nodes in parallel.</span>

<span class="sd">MDP is distributed under the following BSD license::</span>

<span class="sd">    This file is part of Modular toolkit for Data Processing (MDP).</span>
<span class="sd">    All the code in this package is distributed under the following conditions:</span>

<span class="sd">    Copyright (c) 2003-2012, MDP Developers &lt;mdp-toolkit-devel@lists.sourceforge.net&gt;</span>

<span class="sd">    All rights reserved.</span>

<span class="sd">    Redistribution and use in source and binary forms, with or without</span>
<span class="sd">    modification, are permitted provided that the following conditions are met:</span>

<span class="sd">        * Redistributions of source code must retain the above copyright</span>
<span class="sd">          notice, this list of conditions and the following disclaimer.</span>
<span class="sd">        * Redistributions in binary form must reproduce the above copyright</span>
<span class="sd">          notice, this list of conditions and the following disclaimer in the</span>
<span class="sd">          documentation and/or other materials provided with the distribution.</span>
<span class="sd">        * Neither the name of the Modular toolkit for Data Processing (MDP)</span>
<span class="sd">          nor the names of its contributors may be used to endorse or promote</span>
<span class="sd">          products derived from this software without specific prior written</span>
<span class="sd">          permission.</span>

<span class="sd">    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<span class="sd">    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="sd">    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="sd">    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span>
<span class="sd">    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="sd">    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="sd">    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="sd">    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="sd">    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="sd">    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c"># add root of the code to system path</span>
    <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">__file__</span><span class="p">))</span>
    <span class="n">pyspace_path</span> <span class="o">=</span> <span class="n">file_path</span><span class="p">[:</span><span class="n">file_path</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s">&#39;pySPACE&#39;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pyspace_path</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyspace_path</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">cPickle</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">pySPACE</span>
<span class="kn">from</span> <span class="nn">pySPACE.tools.filesystem</span> <span class="kn">import</span> <span class="n">create_directory</span>
<span class="kn">from</span> <span class="nn">pySPACE.tools.socket_utils</span> <span class="kn">import</span> <span class="n">talk</span><span class="p">,</span> <span class="n">inform</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<div class="viewcode-block" id="CrashRecoveryException"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.CrashRecoveryException">[docs]</a><span class="k">class</span> <span class="nc">CrashRecoveryException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to handle crash recovery &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CrashRecoveryException.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.CrashRecoveryException.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow crash recovery.</span>
<span class="sd">        Arguments: (error_string, crashing_obj, parent_exception)</span>
<span class="sd">        The crashing object is kept in self.crashing_obj</span>
<span class="sd">        The triggering parent exception is kept in ``self.parent_exception``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crashing_obj</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_exception</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c"># ?? python 2.5: super(CrashRecoveryException, self).__init__(errstr)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CrashRecoveryException</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errstr</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="CrashRecoveryException.dump"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.CrashRecoveryException.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a pickle dump of the crashing object on filename.</span>
<span class="sd">        If filename is None, the crash dump is saved on a file created by</span>
<span class="sd">        the tempfile module.</span>
<span class="sd">        Return the filename.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">cPickle</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span><span class="o">=</span><span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s">&quot;.pic&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&quot;NodeChainCrash_&quot;</span><span class="p">)</span>
            <span class="n">fl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fdopen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#39;w+b&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fl</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w+b&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crashing_obj</span><span class="p">,</span> <span class="n">fl</span><span class="p">)</span>
        <span class="n">fl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">filename</span>
</div></div>
<div class="viewcode-block" id="NodeChainException"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChainException">[docs]</a><span class="k">class</span> <span class="nc">NodeChainException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for exceptions in node chains.&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="NodeChainExceptionCR"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChainExceptionCR">[docs]</a><span class="k">class</span> <span class="nc">NodeChainExceptionCR</span><span class="p">(</span><span class="n">CrashRecoveryException</span><span class="p">,</span> <span class="n">NodeChainException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to handle crash recovery &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NodeChainExceptionCR.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChainExceptionCR.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow crash recovery.</span>

<span class="sd">        Arguments: (error_string, flow_instance, parent_exception)</span>

<span class="sd">        The triggering parent exception is kept in self.parent_exception.</span>
<span class="sd">        If ``flow_instance._crash_recovery`` is set, save a crash dump of</span>
<span class="sd">        flow_instance on the file self.filename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CrashRecoveryException</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crashing_obj</span><span class="o">.</span><span class="n">_crash_recovery</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">rec</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">CrashRecoveryException</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">dumpinfo</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">A crash dump is available on: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="n">errstr</span><span class="o">+</span><span class="n">dumpinfo</span>

        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errstr</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="NodeChain"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain">[docs]</a><span class="k">class</span> <span class="nc">NodeChain</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reimplement/overwrite mdp.Flow methods e.g., for supervised learning &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NodeChain.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_sequence</span><span class="p">,</span> <span class="n">crash_recovery</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates the NodeChain based on the node_sequence</span>

<span class="sd">        .. note:: The NodeChain cannot be executed before not all trainable</span>
<span class="sd">                  nodes have been trained, i.e. self.trained() == True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">node_sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">node_sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_crash_recovery</span><span class="p">(</span><span class="n">crash_recovery</span><span class="p">)</span>
        <span class="c"># Register the direct predecessor of a node as its input</span>
        <span class="c"># (i.e. we assume linear flows)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_sequence</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">node_sequence</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">register_input_node</span><span class="p">(</span><span class="n">node_sequence</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_test_data</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># set a default run number</span>
        <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_run_number</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c"># give this flow a unique identifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_intermediate_results</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="NodeChain.train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_iterators</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  Train NodeChain with data from iterator or source node</span>

<span class="sd">        The method can proceed in two different ways:</span>

<span class="sd">        *   If no data is provided, it is checked that the first node of</span>
<span class="sd">            the flow is a source node. If that is the case, the data provided</span>
<span class="sd">            by this node is passed forward through the flow. During this</span>
<span class="sd">            forward propagation, the flow is trained.</span>
<span class="sd">            The request of the data is done in the last node.</span>

<span class="sd">        *   If a list of data iterators is provided,</span>
<span class="sd">            then it is checked that no source</span>
<span class="sd">            and split nodes are contained in the NodeChain.</span>
<span class="sd">            these nodes only include already a data handling</span>
<span class="sd">            and should not be used, when training is done in different way.</span>
<span class="sd">            Furthermore, split nodes are relevant for benchmarking.</span>

<span class="sd">            One iterator for each node has to be given.</span>
<span class="sd">            If only one is given, or no list, it is mapped to a list</span>
<span class="sd">            with the same iterator for each node.</span>

<span class="sd">            .. note:: The iterator approach is normally not used in pySPACE,</span>
<span class="sd">                      because pySPACE supplies the data with special</span>
<span class="sd">                      source nodes and is doing the training automatically</span>
<span class="sd">                      without explicit calls on data samples.</span>
<span class="sd">                      The approach came with MDP.</span>

<span class="sd">            .. todo:: The iterator approach needs some use cases and testings,</span>
<span class="sd">                      especially, because it is not used in the normal setting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data_iterators</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Check if no source and split nodes are contained in the node chain</span>
            <span class="k">assert</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_source_node</span><span class="p">()),</span> \
                 <span class="s">&quot;Node chains with source nodes cannot be trained &quot;</span>\
                 <span class="s">&quot;with external data_iterators!&quot;</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">assert</span><span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_split_node</span><span class="p">()),</span> \
                    <span class="s">&quot;Node chains with split nodes cannot be trained &quot;</span>\
                    <span class="s">&quot;with external data_iterators!&quot;</span>
            <span class="c"># prepare iterables</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">data_iterators</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">data_iterators</span> <span class="o">=</span>  <span class="p">[</span><span class="n">data_iterators</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_iterators</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">):</span>
                <span class="n">data_iterators</span> <span class="o">=</span>  <span class="p">[</span><span class="n">data_iterators</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
            <span class="c"># Delegate to iterative training</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_train</span><span class="p">(</span><span class="n">data_iterators</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># Use the pySPACE train semantic and not MDP type</span>
            <span class="c"># Check if the first node of the node chain is a source node</span>
            <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_source_node</span><span class="p">()),</span> \
                 <span class="s">&quot;Training of a node chain without source node requires a &quot;</span>\
                 <span class="s">&quot;data_iterator argument!&quot;</span>
            <span class="c"># This is accomplished by calling the train_sweep method</span>
            <span class="c"># of the last node of the chain. This node will recursively call</span>
            <span class="c"># the train method of all its predecessor nodes</span>
            <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">train_sweep</span><span class="p">(</span><span class="n">use_test_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_test_data</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain.iter_train"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.iter_train">[docs]</a>    <span class="k">def</span> <span class="nf">iter_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_iterables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Train all trainable nodes in the NodeChain with data from iterator</span>

<span class="sd">        *data_iterables* is a list of iterables, one for each node in the chain.</span>
<span class="sd">        The iterators returned by the iterables must return data arrays that</span>
<span class="sd">        are then used for the node training (so the data arrays are the data for</span>
<span class="sd">        the nodes).</span>

<span class="sd">        Note that the data arrays are processed by the nodes</span>
<span class="sd">        which are in front of the node that gets trained, so the data dimension</span>
<span class="sd">        must match the input dimension of the first node.</span>

<span class="sd">        If a node has only a single training phase then instead of an iterable</span>
<span class="sd">        you can alternatively provide an iterator (including generator-type</span>
<span class="sd">        iterators). For nodes with multiple training phases this is not</span>
<span class="sd">        possible, since the iterator cannot be restarted after the first</span>
<span class="sd">        iteration. For more information on iterators and iterables see</span>
<span class="sd">        http://docs.python.org/library/stdtypes.html#iterator-types .</span>

<span class="sd">        In the special case that *data_iterables* is one single array,</span>
<span class="sd">        it is used as the data array *x* for all nodes and training phases.</span>

<span class="sd">        Instead of a data array *x* the iterators can also return a list or</span>
<span class="sd">        tuple, where the first entry is *x* and the following are args for the</span>
<span class="sd">        training of the node (e.g., for supervised training).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_iterables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_check_iterables</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">)</span>

        <span class="c"># train each Node successively</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Training node #</span><span class="si">%d</span><span class="s"> (</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_train_node</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Training finished&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_close_last_node</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NodeChain.trained"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.trained">[docs]</a>    <span class="k">def</span> <span class="nf">trained</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the complete training is finished, i.e. if all nodes have been trained.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
</div>
<div class="viewcode-block" id="NodeChain.execute"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.execute">[docs]</a>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_iterators</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Process the data through all nodes &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data_iterators</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Delegate to super class</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_execute</span><span class="p">(</span><span class="n">data_iterators</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># Use the evaluate semantic</span>
            <span class="c"># Check if the first node of the flow is a source node</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_source_node</span><span class="p">()),</span> \
                 <span class="s">&quot;Evaluation of a node chain without source node requires a &quot;</span> \
                 <span class="s">&quot;data_iterator argument!&quot;</span>
            <span class="c"># This is accomplished by calling the request_data_for_testing</span>
            <span class="c"># method of the last node of the chain. This node will recursively</span>
            <span class="c"># call the request_data_for_testing method of all its predecessor</span>
            <span class="c"># nodes</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NodeChain.iter_execute"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.iter_execute">[docs]</a>    <span class="k">def</span> <span class="nf">iter_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">nodenr</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Process the data through all nodes in the chain till *nodenr*</span>

<span class="sd">        &#39;iterable&#39; is an iterable or iterator (note that a list is also an</span>
<span class="sd">        iterable), which returns data arrays that are used as input.</span>
<span class="sd">        Alternatively, one can specify one data array as input.</span>

<span class="sd">        If &#39;nodenr&#39; is specified, the flow is executed only up to</span>
<span class="sd">        node nr. &#39;nodenr&#39;. This is equivalent to &#39;flow[:nodenr+1](iterable)&#39;.</span>

<span class="sd">        .. note:: In contrary to MDP, results are not concatenated</span>
<span class="sd">                  to one big object. Each data object remains separate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_seq</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">empty_iterator</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">empty_iterator</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_execute_seq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">empty_iterator</span><span class="p">:</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;The execute data iterator is empty.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">NodeChainException</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>


</div>
<div class="viewcode-block" id="NodeChain.save"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">protocol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Save a pickled representation to *filename*</span>

<span class="sd">        If *filename* is None, return a string.</span>

<span class="sd">        .. note:: the pickled NodeChain is not guaranteed to be upward or</span>
<span class="sd">                    backward compatible.</span>
<span class="sd">        .. note:: Having C-Code in the node might cause problems with saving.</span>
<span class="sd">                  Therefore, the code has special handling for the</span>
<span class="sd">                  LibSVMClassifierNode.</span>
<span class="sd">        .. todo:: Intrinsic node methods for storing should be used.</span>
<span class="sd">                  .. seealso:: :func:`store_node_chain`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;LibSVMClassifierNode&quot;</span><span class="p">]</span> \
            <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">multinomial</span><span class="p">:</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;.pickle&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">save_model</span><span class="p">(</span><span class="n">filename</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">indx</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;.model&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">save_model</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;.model&#39;</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">cPickle</span>

        <span class="n">odict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># copy the dict since we change it</span>
        <span class="c"># Remove other non-pickable stuff</span>
        <span class="n">remove_keys</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">odict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&quot;input_node&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">PicklingError</span><span class="p">):</span>
                <span class="n">remove_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">remove_keys</span><span class="p">:</span>
            <span class="n">odict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">odict</span>


        <span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># if protocol != 0 open the file in binary mode</span>
            <span class="k">if</span> <span class="n">protocol</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="s">&#39;wb&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="s">&#39;w&#39;</span>

            <span class="n">flh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span> <span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
            <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flh</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
            <span class="n">flh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="c">#################</span>
<span class="c"># MDP Code copy #</span>

</div>
<div class="viewcode-block" id="NodeChain._propagate_exception"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._propagate_exception">[docs]</a>    <span class="k">def</span> <span class="nf">_propagate_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">):</span>
        <span class="c"># capture exception. the traceback of the error is printed and a</span>
        <span class="c"># new exception, containing the identity of the node in the NodeChain</span>
        <span class="c"># is raised. Allow crash recovery.</span>
        <span class="p">(</span><span class="n">etype</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exception</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span>
                                                   <span class="n">exception</span><span class="p">,</span><span class="n">tb</span><span class="p">))</span>
        <span class="n">act</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">! Exception in node #</span><span class="si">%d</span><span class="s"> (</span><span class="si">%s</span><span class="s">):</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nodenr</span><span class="p">,</span>
                                                     <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">nodenr</span><span class="p">]))</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="mi">40</span><span class="o">*</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span> <span class="s">&#39;Node Traceback:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">40</span><span class="o">*</span><span class="s">&#39;-&#39;</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">NodeChainExceptionCR</span><span class="p">(</span><span class="n">errstr</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain._train_node"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._train_node">[docs]</a>    <span class="k">def</span> <span class="nf">_train_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_iterable</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Train a single node in the flow.</span>

<span class="sd">        nodenr -- index of the node in the flow</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">nodenr</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data_iterable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">()):</span>
            <span class="c"># attempted to train a node although it is not trainable.</span>
            <span class="c"># raise a warning and continue with the next node.</span>
            <span class="c"># wrnstr = &quot;\n! Node %d is not trainable&quot; % nodenr + \</span>
            <span class="c">#        &quot;\nYou probably need a &#39;None&#39; iterable for&quot;+\</span>
            <span class="c">#         &quot; this node. Continuing anyway.&quot;</span>
            <span class="c">#warnings.warn(wrnstr, UserWarning)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">data_iterable</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">is_training</span><span class="p">():</span>
            <span class="c"># None instead of iterable is passed to a training node</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">! Node </span><span class="si">%d</span><span class="s"> is training&quot;</span>
                       <span class="s">&quot; but instead of iterable received &#39;None&#39;.&quot;</span> <span class="o">%</span> <span class="n">nodenr</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">NodeChainException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">data_iterable</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">()):</span>
            <span class="c"># skip training if node is not trainable</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">train_arg_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_required_train_args</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">train_args_needed</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_arg_keys</span><span class="p">))</span>
            <span class="c">## We leave the last training phase open for the</span>
            <span class="c">## CheckpointFlow class.</span>
            <span class="c">## Checkpoint functions must close it explicitly if needed!</span>
            <span class="c">## Note that the last training_phase is closed</span>
            <span class="c">## automatically when the node is executed.</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">empty_iterator</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data_iterable</span><span class="p">:</span>
                    <span class="n">empty_iterator</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="c"># the arguments following the first are passed only to the</span>
                    <span class="c"># currently trained node, allowing the implementation of</span>
                    <span class="c"># supervised nodes</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">arg</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">arg</span> <span class="o">=</span> <span class="p">()</span>
                    <span class="c"># check if the required number of arguments was given</span>
                    <span class="k">if</span> <span class="n">train_args_needed</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_arg_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Wrong number of arguments provided by &quot;</span> <span class="o">+</span>
                                   <span class="s">&quot;the iterable for node #</span><span class="si">%d</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="n">nodenr</span> <span class="o">+</span>
                                   <span class="s">&quot;(</span><span class="si">%d</span><span class="s"> needed, </span><span class="si">%d</span><span class="s"> given).</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_arg_keys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="o">+</span>
                                   <span class="s">&quot;List of required argument keys: &quot;</span> <span class="o">+</span>
                                   <span class="nb">str</span><span class="p">(</span><span class="n">train_arg_keys</span><span class="p">))</span>
                            <span class="k">raise</span> <span class="n">NodeChainException</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                    <span class="c"># filter x through the previous nodes</span>
                    <span class="k">if</span> <span class="n">nodenr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_seq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nodenr</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c"># train current node</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">empty_iterator</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">get_current_train_phase</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;The training data iteration for node &quot;</span>
                                   <span class="s">&quot;no. </span><span class="si">%d</span><span class="s"> could not be repeated for the &quot;</span>
                                   <span class="s">&quot;second training phase, you probably &quot;</span>
                                   <span class="s">&quot;provided an iterator instead of an &quot;</span>
                                   <span class="s">&quot;iterable.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nodenr</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                        <span class="k">raise</span> <span class="n">NodeChainException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;The training data iterator for node &quot;</span>
                                   <span class="s">&quot;no. </span><span class="si">%d</span><span class="s"> is empty.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nodenr</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                        <span class="k">raise</span> <span class="n">NodeChainException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training_hook</span><span class="p">()</span>
                <span class="c"># close the previous training phase</span>
                <span class="n">node</span><span class="o">.</span><span class="n">stop_training</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">TrainingFinishedException</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="c"># attempted to train a node although its training phase is already</span>
            <span class="c"># finished. raise a warning and continue with the next node.</span>
            <span class="n">wrnstr</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">! Node </span><span class="si">%d</span><span class="s"> training phase already finished&quot;</span>
                      <span class="s">&quot; Continuing anyway.&quot;</span> <span class="o">%</span> <span class="n">nodenr</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wrnstr</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NodeChainExceptionCR</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="c"># this exception was already propagated,</span>
            <span class="c"># probably during the execution  of a node upstream in the flow</span>
            <span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exception_only</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">prev</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">act</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">While training node #</span><span class="si">%d</span><span class="s"> (</span><span class="si">%s</span><span class="s">):</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nodenr</span><span class="p">,</span>
                                                         <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">nodenr</span><span class="p">]))</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="mi">40</span><span class="o">*</span><span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">40</span><span class="o">*</span><span class="s">&#39;=&#39;</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">NodeChainException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="c"># capture any other exception occurred during training.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain._stop_training_hook"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._stop_training_hook">[docs]</a>    <span class="k">def</span> <span class="nf">_stop_training_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hook method that is called before stop_training is called.&quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="NodeChain._get_required_train_args"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._get_required_train_args">[docs]</a>    <span class="k">def</span> <span class="nf">_get_required_train_args</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return arguments in addition to self and x for node.train.</span>

<span class="sd">        Arguments that have a default value are ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">inspect</span>
        <span class="n">train_arg_spec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">train</span><span class="p">)</span>
        <span class="n">train_arg_keys</span> <span class="o">=</span> <span class="n">train_arg_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>  <span class="c"># ignore self, x</span>
        <span class="k">if</span> <span class="n">train_arg_spec</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="c"># subtract arguments with a default value</span>
            <span class="n">train_arg_keys</span> <span class="o">=</span> <span class="n">train_arg_keys</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">train_arg_spec</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">train_arg_keys</span>
</div>
<div class="viewcode-block" id="NodeChain._train_check_iterables"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._train_check_iterables">[docs]</a>    <span class="k">def</span> <span class="nf">_train_check_iterables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_iterables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data iterables after some checks and sanitizing.</span>

<span class="sd">        Note that this method does not distinguish between iterables and</span>
<span class="sd">        iterators, so this must be taken care of later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># verifies that the number of iterables matches that of</span>
        <span class="c"># the signal nodes and multiplies them if needed.</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span>

        <span class="c"># # if a single array is given wrap it in a list of lists,</span>
        <span class="c"># # note that a list of 2d arrays is not valid</span>
        <span class="c"># if isinstance(data_iterables, numpy.ndarray):</span>
        <span class="c">#     data_iterables = [[data_iterables]] * len(flow)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;&#39;data_iterables&#39; must be either a list of &quot;</span>
                       <span class="s">&quot;iterables or an array, but got </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                       <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="n">NodeChainException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>

        <span class="c"># check that all elements are iterable</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">iterable</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iterable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">)):</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Element number </span><span class="si">%d</span><span class="s"> in the data_iterables&quot;</span>
                       <span class="s">&quot; list is not an iterable.&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">NodeChainException</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="c"># check that the number of data_iterables is correct</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">):</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s"> data iterables specified,&quot;</span>
                       <span class="s">&quot; </span><span class="si">%d</span><span class="s"> needed&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="n">NodeChainException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_iterables</span>
</div>
<div class="viewcode-block" id="NodeChain._close_last_node"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._close_last_node">[docs]</a>    <span class="k">def</span> <span class="nf">_close_last_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Close the training phase of the last node&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stop_training</span><span class="p">()</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">TrainingFinishedException</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain.set_crash_recovery"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.set_crash_recovery">[docs]</a>    <span class="k">def</span> <span class="nf">set_crash_recovery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set crash recovery capabilities.</span>

<span class="sd">        When a node raises an Exception during training, execution, or</span>
<span class="sd">        inverse execution that the flow is unable to handle, a NodeChainExceptionCR</span>
<span class="sd">        is raised. If crash recovery is set, a crash dump of the flow</span>
<span class="sd">        instance is saved for later inspection. The original exception</span>
<span class="sd">        can be found as the &#39;parent_exception&#39; attribute of the</span>
<span class="sd">        NodeChainExceptionCR instance.</span>

<span class="sd">        - If &#39;state&#39; = False, disable crash recovery.</span>
<span class="sd">        - If &#39;state&#39; is a string, the crash dump is saved on a file</span>
<span class="sd">          with that name.</span>
<span class="sd">        - If &#39;state&#39; = True, the crash dump is saved on a file created by</span>
<span class="sd">          the tempfile module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crash_recovery</span> <span class="o">=</span> <span class="n">state</span>
</div>
<div class="viewcode-block" id="NodeChain._execute_seq"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._execute_seq">[docs]</a>    <span class="k">def</span> <span class="nf">_execute_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nodenr</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Executes input data &#39;x&#39; through the nodes 0..&#39;node_nr&#39; included</span>

<span class="sd">        If no *nodenr* is specified, the complete node chain is used for</span>
<span class="sd">        processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span>
        <span class="k">if</span> <span class="n">nodenr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nodenr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">node_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nodenr</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="n">node_index</span><span class="p">]</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">node_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="NodeChain.copy"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy of the flow.</span>

<span class="sd">        The protocol parameter should not be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="k">if</span> <span class="n">protocol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;protocol parameter to copy() is ignored&quot;</span><span class="p">,</span>
                           <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain.__call__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">nodenr</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling an instance is equivalent to call its &#39;execute&#39; method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_execute</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">nodenr</span><span class="o">=</span><span class="n">nodenr</span><span class="p">)</span>

    <span class="c">###### string representation</span>
</div>
<div class="viewcode-block" id="NodeChain.__str__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">])</span>
        <span class="k">return</span> <span class="s">&#39;[&#39;</span><span class="o">+</span><span class="n">nodes</span><span class="o">+</span><span class="s">&#39;]&#39;</span>
</div>
<div class="viewcode-block" id="NodeChain.__repr__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># this should look like a valid Python expression that</span>
        <span class="c"># could be used to recreate an object with the same value</span>
        <span class="c"># eval(repr(object)) == object</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s">&#39;,</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">+</span><span class="s">&#39; &#39;</span><span class="o">*</span><span class="n">pad</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">])</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">([</span><span class="si">%s</span><span class="s">])&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="c">###### private container methods</span>
</div>
<div class="viewcode-block" id="NodeChain.__len__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain._check_dimension_consistency"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._check_dimension_consistency">[docs]</a>    <span class="k">def</span> <span class="nf">_check_dimension_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise ValueError when both dimensions are set and different.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">out</span> <span class="ow">and</span> <span class="n">inp</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">out</span> <span class="o">!=</span> <span class="n">inp</span><span class="p">:</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="s">&quot;dimensions mismatch: </span><span class="si">%s</span><span class="s"> != </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">inp</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain._check_nodes_consistency"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._check_nodes_consistency">[docs]</a>    <span class="k">def</span> <span class="nf">_check_nodes_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check the dimension consistency of a list of nodes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flow</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span>
        <span class="n">len_flow</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_flow</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">output_dim</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">input_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_dimension_consistency</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain._check_value_type_isnode"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain._check_value_type_isnode">[docs]</a>    <span class="k">def</span> <span class="nf">_check_value_type_isnode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">pySPACE</span><span class="o">.</span><span class="n">missions</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseNode</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;flow item must be Node instance&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain.__getitem__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">flow_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_slice</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">flow_slice</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="NodeChain.__setitem__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_value_type_isnode</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_value_type_isnode</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c"># make a copy of list</span>
        <span class="n">flow_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
        <span class="n">flow_copy</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c"># check dimension consistency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
        <span class="c"># if no exception was raised, accept the new sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">flow_copy</span>
</div>
<div class="viewcode-block" id="NodeChain.__delitem__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__delitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c"># make a copy of list</span>
        <span class="n">flow_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">flow_copy</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c"># check dimension consistency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
        <span class="c"># if no exception was raised, accept the new sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">flow_copy</span>
</div>
<div class="viewcode-block" id="NodeChain.__contains__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">__contains__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain.__iter__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NodeChain.__add__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c"># append other to self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NodeChain</span><span class="p">):</span>
            <span class="n">flow_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
            <span class="c"># check dimension consistency</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
            <span class="c"># if no exception was raised, accept the new sequence</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pySPACE</span><span class="o">.</span><span class="n">missions</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseNode</span><span class="p">):</span>
            <span class="n">flow_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
            <span class="n">flow_copy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="c"># check dimension consistency</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
            <span class="c"># if no exception was raised, accept the new sequence</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;can only concatenate flow or node&#39;</span>
                       <span class="s">&#39; (not </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s">) to flow&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeChain.__iadd__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.__iadd__">[docs]</a>    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c"># append other to self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NodeChain</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">flow</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pySPACE</span><span class="o">.</span><span class="n">missions</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">BaseNode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;can only concatenate flow or node&#39;</span>
                       <span class="s">&#39; (not </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s">) to flow&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c">###### public container methods</span>
</div>
<div class="viewcode-block" id="NodeChain.append"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;flow.append(node) -- append node to flow end&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="NodeChain.extend"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;flow.extend(iterable) -- extend flow by appending</span>
<span class="sd">        elements from the iterable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NodeChain</span><span class="p">):</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;can only concatenate flow&#39;</span>
                       <span class="s">&#39; (not </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s">) to flow&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="NodeChain.insert"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;flow.insert(index, node) -- insert node before index&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="NodeChain.pop"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;flow.pop([index]) -&gt; node -- remove and return node at index</span>
<span class="sd">        (default last)&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span>
</div>
<div class="viewcode-block" id="NodeChain.reset"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChain.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the flow and obey permanent_attributes where available</span>

<span class="sd">        Method was moved to the end of class code, due to program environment</span>
<span class="sd">        problems which needed the __getitem__ method beforehand.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
</div></div>
<div class="viewcode-block" id="BenchmarkNodeChain"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.BenchmarkNodeChain">[docs]</a><span class="k">class</span> <span class="nc">BenchmarkNodeChain</span><span class="p">(</span><span class="n">NodeChain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This subclass  overwrites the train method in order</span>
<span class="sd">    to provide a more convenient way of doing supervised learning.</span>
<span class="sd">    Furthermore, it contains a benchmark method that can be used for</span>
<span class="sd">    benchmarking.</span>

<span class="sd">    This includes logging, setting of run numbers,</span>
<span class="sd">    delivering the result collection, handling of source and sink nodes, ...</span>

<span class="sd">    :Author: Jan Hendrik Metzen (jhm@informatik.uni-bremen.de)</span>
<span class="sd">    :Created: 2008/08/18</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BenchmarkNodeChain.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.BenchmarkNodeChain.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates the BenchmarkNodeChain based on the node_sequence &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BenchmarkNodeChain</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">node_sequence</span><span class="p">)</span>
        <span class="c"># Each BenchmarkNodeChain must start with an source node</span>
        <span class="c"># and end with a sink node</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_source_node</span><span class="p">()),</span> \
                <span class="s">&quot;A benchmark flow must start with a source node&quot;</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_sink_node</span><span class="p">()),</span> \
                <span class="s">&quot;A benchmark flow must end with a sink node&quot;</span>
</div>
<div class="viewcode-block" id="BenchmarkNodeChain.use_next_split"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.BenchmarkNodeChain.use_next_split">[docs]</a>    <span class="k">def</span> <span class="nf">use_next_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use the next split of the data into training and test data</span>

<span class="sd">        This method is useful for pySPACE-benchmarking</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This is handled by calling use_next_split() of the last node of</span>
        <span class="c"># the flow which will recursively call predecessor nodes in the flow</span>
        <span class="c"># until a node is found that handles the splitting</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">use_next_split</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BenchmarkNodeChain.benchmark"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.BenchmarkNodeChain.benchmark">[docs]</a>    <span class="k">def</span> <span class="nf">benchmark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_collection</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">persistency_directory</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">store_node_chain</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform the benchmarking of this data flow with the given collection</span>

<span class="sd">        Benchmarking is accomplished by iterating through all splits of the</span>
<span class="sd">        data into training and test data.</span>

<span class="sd">        **Parameters**:</span>

<span class="sd">            :input_collection:</span>
<span class="sd">                A sequence of data/label-tuples that serves as a generator or a</span>
<span class="sd">                BaseDataset which contains the data to be processed.</span>

<span class="sd">            :run:</span>
<span class="sd">                The current run which defines all random seeds within the flow.</span>

<span class="sd">            :persistency_directory:</span>
<span class="sd">                Optional information of the nodes as well as the trained node chain</span>
<span class="sd">                (if *store_node_chain* is not False) are stored to the given</span>
<span class="sd">                *persistency_directory*.</span>

<span class="sd">            :store_node_chain:</span>
<span class="sd">                If True the trained flow is stored to *persistency_directory*.</span>
<span class="sd">                If *store_node_chain* is a tuple of length 2---lets say (i1,i2)--</span>
<span class="sd">                only the subflow starting at the i1-th node and ending at the</span>
<span class="sd">                (i2-1)-th node is stored. This may be useful when the stored</span>
<span class="sd">                flow should be used in an ensemble.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Inform the first node of this flow about the input collection</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">input_collection</span><span class="p">,</span><span class="s">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="c"># assume a generator is given</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_generator</span><span class="p">(</span><span class="n">input_collection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># assume BaseDataset</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_input_dataset</span><span class="p">(</span><span class="n">input_collection</span><span class="p">)</span>

        <span class="c"># Inform all nodes recursively about the number of the current run</span>
        <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_run_number</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">run</span><span class="p">))</span>
        <span class="c"># set temp file folder</span>
        <span class="k">if</span> <span class="n">persistency_directory</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_temp_dir</span><span class="p">(</span><span class="n">persistency_directory</span><span class="o">+</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="o">+</span><span class="s">&quot;temp_dir&quot;</span><span class="p">)</span>

        <span class="n">split_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># For every split of the dataset</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span> <span class="c"># As long as more splits are available</span>
            <span class="c"># Compute the results for the current split</span>
            <span class="c"># by calling the method on its last node</span>
            <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">process_current_split</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">persistency_directory</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">store_node_chain</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">store_node_chain</span><span class="p">(</span><span class="n">persistency_directory</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span> <span class="o">+</span> \
                                <span class="s">&quot;node_chain_sp</span><span class="si">%s</span><span class="s">.pickle&quot;</span> <span class="o">%</span> <span class="n">split_counter</span><span class="p">,</span> <span class="n">store_node_chain</span><span class="p">)</span>

                <span class="c"># Store nodes that should be persistent</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">store_persistent_nodes</span><span class="p">(</span><span class="n">persistency_directory</span><span class="p">)</span>

            <span class="c"># If no more splits are available</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_next_split</span><span class="p">():</span>
                <span class="k">break</span>

            <span class="n">split_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># print &quot;Input benchmark&quot;</span>
        <span class="c"># print gc.get_referrers(self[0].collection)</span>

        <span class="c"># During the flow numerous pointers are put to the flow but they are</span>
        <span class="c"># not deleted. So memory is not given free, which can be seen by the</span>
        <span class="c"># upper comment. Therefore we now free the input collection and only</span>
        <span class="c"># then the gc collector can free the memory. Otherwise under not yet</span>
        <span class="c"># found reasons, the pointers to the input collection will remain even</span>
        <span class="c"># between processes.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">input_collection</span><span class="p">,</span><span class="s">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_generator</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_input_dataset</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="c"># Return the result collection of this flow</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_result_dataset</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BenchmarkNodeChain.__call__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.BenchmarkNodeChain.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">train_instances</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">runs</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot; Call *execute* or *benchmark* and return (id, PerformanceResultSummary)</span>

<span class="sd">        If *iterable* is given, calling an instance is equivalent to call its</span>
<span class="sd">        &#39;execute&#39; method.</span>
<span class="sd">        If *train_instances* and *runs* are given, &#39;benchmark&#39; is called for</span>
<span class="sd">        every run number specified and results are merged. This is useful for</span>
<span class="sd">        e.g. parallel execution of subflows with the multiprocessing module,</span>
<span class="sd">        since instance methods can not be serialized in Python but whole objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">iterable</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">train_instances</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">runs</span> <span class="o">!=</span> <span class="p">[]:</span> <span class="c"># parallelization case</span>
            <span class="c"># we have to reinitialize logging cause otherwise deadlocks occur</span>
            <span class="c"># when parallelization is done via multiprocessing.Pool</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prepare_logging</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">run</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">runs</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">benchmark</span><span class="p">(</span><span class="n">train_instances</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="n">run</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">result_collection</span> <span class="o">=</span> <span class="n">result</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_collection</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="c"># reset node chain for new training if another call of</span>
                <span class="c"># :func:`benchmark` is expected.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ind</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">runs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clean_logging</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">result_collection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;__call__ methods needs at least one parameter (data)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="BenchmarkNodeChain.store_node_chain"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.BenchmarkNodeChain.store_node_chain">[docs]</a>    <span class="k">def</span> <span class="nf">store_node_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_dir</span><span class="p">,</span> <span class="n">store_node_chain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pickle this flow into *result_dir* for later usage&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store_node_chain</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">store_node_chain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="c"># Keep only subflow starting at the i1-th node and ending at the</span>
            <span class="c"># (i2-1) node.</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">NodeChain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">store_node_chain</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">store_node_chain</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store_node_chain</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="c"># Keep only nodes with indices contained in the list</span>
            <span class="c"># nodes have to be copied, otherwise input_node-refs of current flow</span>
            <span class="c"># are overwritten</span>
            <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
            <span class="n">store_node_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span> \
                                                           <span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">store_node_chain</span><span class="p">]</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">NodeChain</span><span class="p">(</span><span class="n">store_node_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Per default, get rid of source and sink nodes</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">NodeChain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">input_node</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_node</span>
        <span class="n">flow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_node</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">flow</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">result_dir</span><span class="p">)</span>
        <span class="n">flow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_node</span> <span class="o">=</span> <span class="n">input_node</span>
</div>
<div class="viewcode-block" id="BenchmarkNodeChain.prepare_logging"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.BenchmarkNodeChain.prepare_logging">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_logging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set up logging</span>

<span class="sd">        This method is only needed if one forks subflows, i.e. to execute them</span>
<span class="sd">        via multiprocessing.Pool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Prepare remote logging</span>
        <span class="n">root_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">(),</span>
                                                   <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>
        <span class="n">root_logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">root_logger</span><span class="o">.</span><span class="n">propagate</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">root_logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">SocketHandler</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">(),</span>
                                      <span class="n">logging</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">DEFAULT_TCP_LOGGING_PORT</span><span class="p">)</span>
            <span class="n">root_logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BenchmarkNodeChain.clean_logging"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.BenchmarkNodeChain.clean_logging">[docs]</a>    <span class="k">def</span> <span class="nf">clean_logging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove logging handlers if existing</span>

<span class="sd">        Call this method only if you have called *prepare_logging* before.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Remove potential logging handlers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">root_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">(),</span>
                                            <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>
            <span class="n">root_logger</span><span class="o">.</span><span class="n">removeHandler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BenchmarkNodeChain.store_persistent_nodes"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.BenchmarkNodeChain.store_persistent_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">store_persistent_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result_dir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Store all nodes that should be persistent &quot;&quot;&quot;</span>
        <span class="c"># For all node</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># Store them in the result dir if they enabled storing</span>
            <span class="n">node</span><span class="o">.</span><span class="n">store_state</span><span class="p">(</span><span class="n">result_dir</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="NodeChainFactory"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChainFactory">[docs]</a><span class="k">class</span> <span class="nc">NodeChainFactory</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Provide static methods to create and instantiate data flows</span>

<span class="sd">    :Author: Jan Hendrik Metzen (jhm@informatik.uni-bremen.de)</span>
<span class="sd">    :Created: 2009/01/26</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="NodeChainFactory.flow_from_yaml"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChainFactory.flow_from_yaml">[docs]</a>    <span class="k">def</span> <span class="nf">flow_from_yaml</span><span class="p">(</span><span class="n">Flow_Class</span><span class="p">,</span> <span class="n">flow_spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a Flow object</span>

<span class="sd">        Reads from the given *flow_spec*, which should be a valid YAML</span>
<span class="sd">        specification of a NodeChain object, and returns this dataflow</span>
<span class="sd">        object.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            :Flow_Class:</span>
<span class="sd">                The class name of node chain to create. Valid are &#39;NodeChain&#39; and</span>
<span class="sd">                &#39;BenchmarkNodeChain&#39;.</span>

<span class="sd">            :flow_spec:</span>
<span class="sd">                A valid YAML specification stream; this could be a file object,</span>
<span class="sd">                a string representation of the YAML file or the Python</span>
<span class="sd">                representation of the YAML file (list of dicts)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pySPACE.missions.nodes.base_node</span> <span class="kn">import</span> <span class="n">BaseNode</span>
        <span class="c"># Reads and parses the YAML file if necessary</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">flow_spec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">dataflow_spec</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">flow_spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dataflow_spec</span> <span class="o">=</span> <span class="n">flow_spec</span>
        <span class="n">node_sequence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># For all nodes of the flow</span>
        <span class="k">for</span> <span class="n">node_spec</span> <span class="ow">in</span> <span class="n">dataflow_spec</span><span class="p">:</span>
            <span class="c"># Use factory method to create node</span>
            <span class="n">node_obj</span> <span class="o">=</span> <span class="n">BaseNode</span><span class="o">.</span><span class="n">node_from_yaml</span><span class="p">(</span><span class="n">node_spec</span><span class="p">)</span>

            <span class="c"># Append this node to the sequence of node</span>
            <span class="n">node_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_obj</span><span class="p">)</span>

        <span class="c"># Check if the nodes have to cache their outputs</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_sequence</span><span class="p">):</span>
            <span class="c"># If a node is trainable, it uses the outputs of its input node</span>
            <span class="c"># at least twice, so we have to cache.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">():</span>
                <span class="n">node_sequence</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">caching</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
            <span class="c"># Split node might also request the data from their input nodes</span>
            <span class="c"># (once for each split), depending on their implementation. We</span>
            <span class="c"># assume the worst case and activate caching</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_split_node</span><span class="p">():</span>
                <span class="n">node_sequence</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_permanent_attributes</span><span class="p">(</span><span class="n">caching</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c"># Create the flow based on the node sequence and the given flow class</span>
        <span class="c"># and return it</span>
        <span class="k">return</span> <span class="n">Flow_Class</span><span class="p">(</span><span class="n">node_sequence</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="NodeChainFactory.instantiate"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.NodeChainFactory.instantiate">[docs]</a>    <span class="k">def</span> <span class="nf">instantiate</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">parametrization</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Instantiate a template recursively for the given parameterization</span>

<span class="sd">        Instantiate means to replace the parameter in the template by the</span>
<span class="sd">        chosen value.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        :template:</span>
<span class="sd">            A dictionary with key-value pairs, where values might contain</span>
<span class="sd">            parameter keys which have to be replaced. A typical example of a</span>
<span class="sd">            template would be a Python representation of a node read from YAML.</span>

<span class="sd">        :parametrization:</span>
<span class="sd">            A dictionary with parameter names as keys and exact one value for</span>
<span class="sd">            this parameter as value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">template</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">parametrization</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="c"># Replacement</span>
                <span class="n">instance</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">parametrization</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span> <span class="c"># Recursive call</span>
                <span class="n">instance</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">NodeChainFactory</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">parametrization</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span> <span class="c"># String replacement</span>
                <span class="k">for</span> <span class="n">param_key</span><span class="p">,</span> <span class="n">param_value</span> <span class="ow">in</span> <span class="n">parametrization</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">param_key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">param_value</span><span class="p">))</span>
                <span class="n">instance</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;__iter__&quot;</span><span class="p">):</span> <span class="c"># Iterate over all items in sequence</span>
                <span class="n">instance</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">iter_item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">iter_item</span> <span class="ow">in</span> <span class="n">parametrization</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="c"># Replacement</span>
                        <span class="n">instance</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parametrization</span><span class="p">[</span><span class="n">iter_item</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">instance</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_item</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># Not parameterized</span>
                <span class="n">instance</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">instance</span>

</div></div>
<div class="viewcode-block" id="SubflowHandler"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.SubflowHandler">[docs]</a><span class="k">class</span> <span class="nc">SubflowHandler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Interface for nodes to generate and execute subflows (subnode-chains)</span>

<span class="sd">    A subflow means a node chain used inside a node for processing data.</span>

<span class="sd">    This class provides functions that can be used by nodes to generate and</span>
<span class="sd">    execute subflows. It serves thereby as a communication daemon to the</span>
<span class="sd">    backend (if it is used).</span>

<span class="sd">    Most important when inheriting from this class is that the subclass MUST be</span>
<span class="sd">    a node. The reason is that this class uses node functionality, e.g. logging,</span>
<span class="sd">    the *temp_dir*-variable and so on.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        :processing_modality:</span>
<span class="sd">            One of the valid strings: &#39;backend&#39;, &#39;serial&#39;, &#39;local&#39;.</span>

<span class="sd">                :backend:</span>
<span class="sd">                    The current backends modality is used. This is implemented</span>
<span class="sd">                    at the moment only for &#39;LoadlevelerBackend&#39; and &#39;LocalBackend&#39;.</span>

<span class="sd">                :serial:</span>
<span class="sd">                    All subflows are executed sequentially, i.e. one after the</span>
<span class="sd">                    other.</span>

<span class="sd">                :local:</span>
<span class="sd">                    Subflows are executed in a Pool using *pool_size* cpus. This</span>
<span class="sd">                    may be also needed when no backend is used.</span>

<span class="sd">            (*optional, default: &#39;serial&#39;*)</span>

<span class="sd">        :pool_size:</span>
<span class="sd">            If a parallelization is based on using several processes on a local</span>
<span class="sd">            system in parallel, e.g. option &#39;backend&#39; and</span>
<span class="sd">            :class:`pySPACEMulticoreBackend`</span>
<span class="sd">            or option</span>
<span class="sd">            &#39;local&#39;, the number of worker processes for subflow evaluation has</span>
<span class="sd">            to be specified.</span>

<span class="sd">            .. note:: When using the LocalBackend, there is also the possibility</span>
<span class="sd">                      to specify the pool size of parallel executed</span>
<span class="sd">                      processes, e.g. data sets. Your total number of cpu&#39;s</span>
<span class="sd">                      should be pool size (pySPACE) + pool size (subflows).</span>

<span class="sd">            (*optional, default: 2*)</span>

<span class="sd">        :batch_size:</span>
<span class="sd">            If parallelization of subflow execution is done together with the</span>
<span class="sd">            :class:`~pySPACE.environments.backends.ll_backend.LoadLevelerBackend`,</span>
<span class="sd">            *batch_size* determines how many subflows are executed in one</span>
<span class="sd">            serial LoadLeveler job. This option is useful if execution of a</span>
<span class="sd">            single subflow is really short (range of seconds) since there is</span>
<span class="sd">            significant overhead in creating new jobs.</span>

<span class="sd">            (*optional, default: 1*)</span>

<span class="sd">    :Author: Anett Seeland (anett.seeland@dfki.de)</span>
<span class="sd">    :Created: 2012/09/04</span>
<span class="sd">    :LastChange: 2012/11/06 batch_size option added</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SubflowHandler.__init__"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.SubflowHandler.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processing_modality</span><span class="o">=</span><span class="s">&#39;serial&#39;</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modality</span> <span class="o">=</span> <span class="n">processing_modality</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pool_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="c"># a flag to send pool_size / batch_size only once to the backend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">already_send</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend_name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># to indicate the end of a message received over a socket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_token</span> <span class="o">=</span> <span class="s">&#39;!END!&#39;</span>

        <span class="k">if</span> <span class="n">processing_modality</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;serial&quot;</span><span class="p">,</span> <span class="s">&quot;local&quot;</span><span class="p">,</span> <span class="s">&quot;backend&quot;</span><span class="p">]:</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Processing modality not found! Serial mode is used!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modality</span> <span class="o">=</span> <span class="s">&#39;serial&#39;</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="SubflowHandler.generate_subflow"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.SubflowHandler.generate_subflow">[docs]</a>    <span class="k">def</span> <span class="nf">generate_subflow</span><span class="p">(</span><span class="n">flow_template</span><span class="p">,</span> <span class="n">parametrization</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                                  <span class="n">flow_class</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a *flow_class* object of the given *flow_template*</span>

<span class="sd">        This methods wraps two function calls (NodeChainFactory.instantiate and</span>
<span class="sd">        NodeChainFactory.flow_from_yaml.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            :flow_template:</span>
<span class="sd">                List of dicts - a valid representation of a node chain</span>

<span class="sd">            :parametrization:</span>
<span class="sd">                A dictionary with parameter names as keys and exact one value for</span>
<span class="sd">                this parameter as value. Passed to NodeChainFactory.instantiate</span>

<span class="sd">                (*optional, default: None*)</span>

<span class="sd">            :flow_class:</span>
<span class="sd">                The flow class name of which an object should be returned</span>

<span class="sd">                (*optional, default: BenchmarkNodeChain*)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flow_class</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">flow_class</span> <span class="o">=</span> <span class="n">BenchmarkNodeChain</span>
        <span class="c"># check whether params are given</span>
        <span class="k">if</span> <span class="n">parametrization</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">flow_spec</span> <span class="o">=</span> <span class="p">[</span><span class="n">NodeChainFactory</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">node_templ</span><span class="p">,</span> <span class="n">parametrization</span><span class="p">)</span> \
                                                <span class="k">for</span> <span class="n">node_templ</span> <span class="ow">in</span> <span class="n">flow_template</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flow_spec</span> <span class="o">=</span> <span class="n">flow_template</span>
        <span class="c"># create a new Benchmark flow</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="n">NodeChainFactory</span><span class="o">.</span><span class="n">flow_from_yaml</span><span class="p">(</span><span class="n">flow_class</span><span class="p">,</span> <span class="n">flow_spec</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">flow</span>
</div>
<div class="viewcode-block" id="SubflowHandler.execute_subflows"><a class="viewcode-back" href="../../../../api/generated/pySPACE.environments.chains.node_chain.html#pySPACE.environments.chains.node_chain.SubflowHandler.execute_subflows">[docs]</a>    <span class="k">def</span> <span class="nf">execute_subflows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_instances</span><span class="p">,</span> <span class="n">subflows</span><span class="p">,</span> <span class="n">run_numbers</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Execute subflows and return result collection.</span>

<span class="sd">        **Parameters**</span>
<span class="sd">            :training_instances:</span>
<span class="sd">                List of training instances which should be used to execute</span>
<span class="sd">                *subflows*.</span>

<span class="sd">            :subflows:</span>
<span class="sd">                List of BenchmarkNodeChain objects.</span>

<span class="sd">                ..note:: Note that every subflow object is stored in memory!</span>

<span class="sd">            :run_numbers:</span>
<span class="sd">                All subflows will be executed with every run_number specified in</span>
<span class="sd">                this list. If None, the current self.run_number (from the node</span>
<span class="sd">                class) is used.</span>

<span class="sd">                (*optional, default: None*)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">run_numbers</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">run_numbers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">run_number</span><span class="p">]</span>
        <span class="c"># in case of serial backend, modality is mapped to serial</span>
        <span class="c"># in the other case communication must be set up and</span>
        <span class="c"># jobs need to be submitted to backend</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modality</span> <span class="o">==</span> <span class="s">&#39;backend&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span> <span class="o">=</span> <span class="n">pySPACE</span><span class="o">.</span><span class="n">configuration</span><span class="o">.</span><span class="n">backend_com</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># ask for backend_name</span>
                <span class="c"># create a socket and keep it alive as long as possible since</span>
                <span class="c"># handshaking costs really time</span>
                <span class="n">client_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
                <span class="n">client_socket</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span><span class="p">)</span>
                <span class="n">client_socket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_name</span> <span class="o">=</span> <span class="n">talk</span><span class="p">(</span><span class="s">&#39;name&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_token</span><span class="p">,</span>
                <span class="n">client_socket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">warnings</span> <span class="c">#necessary for serial backend!</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Seems that no backend is used! Modality of subflow execution &quot;</span>\
                <span class="s">&quot;has to be specified! Assuming serial backend.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">backend_name</span> <span class="o">=</span> <span class="s">&#39;serial&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Preparing subflows for backend execution.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;loadl&#39;</span><span class="p">,</span><span class="s">&#39;mcore&#39;</span><span class="p">]</span> <span class="p">:</span>
                <span class="c"># we have to pickle training instances and store it on disk</span>
                <span class="n">store_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">temp_dir</span><span class="p">,</span>
                                                    <span class="s">&quot;sp</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_split</span><span class="p">)</span>
                <span class="n">create_directory</span><span class="p">(</span><span class="n">store_path</span><span class="p">)</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">store_path</span><span class="p">,</span> <span class="s">&quot;subflow_data.pickle&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                    <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">train_instances</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;wb&#39;</span><span class="p">),</span>
                                              <span class="n">protocol</span><span class="o">=</span><span class="n">cPickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
                <span class="n">subflows_to_compute</span> <span class="o">=</span> <span class="p">[</span><span class="n">subflows</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> \
                                                           <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subflows</span><span class="p">))]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_name</span> <span class="o">==</span> <span class="s">&#39;loadl&#39;</span><span class="p">:</span>
                    <span class="c"># send batch_size to backend if not already done</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">already_send</span><span class="p">:</span>
                        <span class="n">client_socket</span> <span class="o">=</span> <span class="n">inform</span><span class="p">(</span><span class="s">&quot;subflow_batchsize;</span><span class="si">%d%s</span><span class="s">&quot;</span> <span class="o">%</span> \
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_token</span><span class="p">),</span>
                                            <span class="n">client_socket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">already_send</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">for</span> <span class="n">subflow</span> <span class="ow">in</span> <span class="n">subflows</span><span class="p">:</span>
                        <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">subflow</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">store_path</span><span class="p">,</span>
                                                         <span class="n">subflow</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="s">&quot;.pickle&quot;</span><span class="p">),</span><span class="s">&quot;wb&quot;</span><span class="p">),</span>
                                     <span class="n">protocol</span><span class="o">=</span><span class="n">cPickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
                    <span class="n">send_flows</span> <span class="o">=</span> <span class="n">subflows_to_compute</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># backend_name == local</span>
                    <span class="c"># send pool_size to backend if not already done</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">already_send</span><span class="p">:</span>
                        <span class="n">client_socket</span> <span class="o">=</span> <span class="n">inform</span><span class="p">(</span><span class="s">&quot;subflow_poolsize;</span><span class="si">%d%s</span><span class="s">&quot;</span> <span class="o">%</span> \
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pool_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_token</span><span class="p">),</span>
                                            <span class="n">client_socket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">already_send</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="c"># send flow objects via socket</span>
                    <span class="n">send_flows</span> <span class="o">=</span> <span class="p">[</span><span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">subflow</span><span class="p">,</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span> \
                                  <span class="k">for</span> <span class="n">subflow</span> <span class="ow">in</span> <span class="n">subflows</span><span class="p">]</span>
                <span class="c"># inform backend</span>
                <span class="n">client_socket</span><span class="p">,</span><span class="n">msg</span>  <span class="o">=</span> <span class="n">talk</span><span class="p">(</span><span class="s">&#39;execute_subflows;</span><span class="si">%s</span><span class="s">;</span><span class="si">%d</span><span class="s">;</span><span class="si">%s</span><span class="s">;</span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                                   <span class="p">(</span><span class="n">store_path</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">subflows</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">send_flows</span><span class="p">),</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">run_numbers</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_token</span><span class="p">),</span>
                                               <span class="n">client_socket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span><span class="p">)</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

                <span class="n">not_finished_subflows</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">subflows_to_compute</span><span class="p">)</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_finished_subflows</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># ask backend for finished jobs</span>
                    <span class="n">client_socket</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">talk</span><span class="p">(</span><span class="s">&#39;is_ready;</span><span class="si">%d</span><span class="s">;</span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">not_finished_subflows</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">not_finished_subflows</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">end_token</span><span class="p">),</span> <span class="n">client_socket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span><span class="p">)</span>
                    <span class="c"># parse message</span>
                    <span class="n">finished_subflows</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="c">#should be a set</span>
                    <span class="c"># set difference</span>
                    <span class="n">not_finished_subflows</span> <span class="o">-=</span> <span class="n">finished_subflows</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_name</span> <span class="o">==</span> <span class="s">&#39;loadl&#39;</span><span class="p">:</span>
                    <span class="c"># read results and delete store_dir</span>
                    <span class="n">result_pattern</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">store_path</span><span class="p">,</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">_result.pickle&#39;</span><span class="p">)</span>
                    <span class="n">result_collections</span> <span class="o">=</span> <span class="p">[</span><span class="n">cPickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">result_pattern</span> <span class="o">%</span> \
                        <span class="n">subflows</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">,</span><span class="s">&#39;rb&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subflows</span><span class="p">))]</span>
                    <span class="c"># ..todo:: check if errors have occurred and if so do not delete!</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">store_path</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># backend_name == mcore</span>
                    <span class="c"># ask backend to send results</span>
                    <span class="n">client_socket</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">talk</span><span class="p">(</span><span class="s">&quot;send_results;</span><span class="si">%s</span><span class="s">!END!&quot;</span> <span class="o">%</span> \
                            <span class="n">subflows_to_compute</span><span class="p">,</span> <span class="n">client_socket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_com</span><span class="p">)</span>
                    <span class="c"># should be a list of collections</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">result_collections</span> <span class="o">=</span> <span class="p">[</span><span class="n">cPickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Finished subflow execution.&quot;</span><span class="p">)</span>
                <span class="n">client_socket</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
                <span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">result_collections</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_name</span> <span class="o">==</span> <span class="s">&#39;serial&#39;</span><span class="p">:</span>
                <span class="c"># do the same as modality==&#39;serial&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">modality</span> <span class="o">=</span> <span class="s">&#39;serial&#39;</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># e.g. mpi backend    :</span>
                <span class="kn">import</span> <span class="nn">warnings</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Subflow Handling with </span><span class="si">%s</span><span class="s"> backend not supported,&quot;</span>\
                              <span class="s">&quot; serial-modality is used!&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">modality</span> <span class="o">=</span> <span class="s">&#39;serial&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modality</span> <span class="o">==</span> <span class="s">&#39;serial&#39;</span><span class="p">:</span>
            <span class="c"># serial execution</span>
            <span class="c"># .. note:: the here executed flows can not store anything.</span>
            <span class="c">#           meta data of result collection is NOT updated!</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">subflow</span><span class="p">(</span><span class="n">train_instances</span><span class="o">=</span><span class="n">train_instances</span><span class="p">,</span>
                               <span class="n">runs</span><span class="o">=</span><span class="n">run_numbers</span><span class="p">)</span> <span class="k">for</span> <span class="n">subflow</span> <span class="ow">in</span> <span class="n">subflows</span><span class="p">]</span>
            <span class="n">result_collections</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result_collections</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># modality local, e.g. usage without backend in application case</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Subflow Handler starts processes in pool.&quot;</span><span class="p">)</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pool_size</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">subflow</span><span class="p">,</span>
                                        <span class="n">kwds</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;train_instances&quot;</span><span class="p">:</span> <span class="n">train_instances</span><span class="p">,</span>
                                              <span class="s">&quot;runs&quot;</span><span class="p">:</span> <span class="n">run_numbers</span><span class="p">})</span> \
                       <span class="k">for</span> <span class="n">subflow</span> <span class="ow">in</span> <span class="n">subflows</span><span class="p">]</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s">&quot;Waiting for parallel processes to finish.&quot;</span><span class="p">)</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="n">result_collections</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">pool</span>
            <span class="k">return</span> <span class="n">result_collections</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">pySPACE 1.0 release documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, pySPACE Developer Team.
      Last updated on Nov 26, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>